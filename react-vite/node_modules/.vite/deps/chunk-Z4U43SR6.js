import {
  activeElement,
  arrow,
  autoPlacement,
  autoUpdate,
  computePosition,
  contains,
  detectOverflow,
  evaluate,
  flip,
  floor,
  getComputedStyle,
  getDocument,
  getNodeName,
  getOverflowAncestors,
  getParentNode,
  getPlatform,
  getTarget,
  getUserAgent,
  getWindow,
  hide,
  init_floating_ui_react_dom,
  init_floating_ui_react_utils,
  init_floating_ui_utils,
  init_floating_ui_utils_dom,
  init_index_esm,
  inline,
  isElement,
  isEventTargetWithin,
  isHTMLElement,
  isLastTraversableNode,
  isMac,
  isMouseLikePointerType,
  isReactEvent,
  isRootElement,
  isSafari,
  isTabbable,
  isTypeableCombobox,
  isTypeableElement,
  isVirtualClick,
  isVirtualPointerEvent,
  limitShift,
  max,
  offset,
  platform,
  round,
  shift,
  size,
  stopEvent,
  tabbable,
  useFloating
} from "./chunk-5L4KA5R2.js";
import {
  require_react_dom
} from "./chunk-CXJOIMMF.js";
import {
  require_react
} from "./chunk-4UQS7KPA.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/clsx/dist/clsx.js
var require_clsx = __commonJS({
  "node_modules/clsx/dist/clsx.js"(exports, module) {
    function r(e2) {
      var o, t, f = "";
      if ("string" == typeof e2 || "number" == typeof e2)
        f += e2;
      else if ("object" == typeof e2)
        if (Array.isArray(e2)) {
          var n = e2.length;
          for (o = 0; o < n; o++)
            e2[o] && (t = r(e2[o])) && (f && (f += " "), f += t);
        } else
          for (t in e2)
            e2[t] && (f && (f += " "), f += t);
      return f;
    }
    function e() {
      for (var e2, o, t = 0, f = "", n = arguments.length; t < n; t++)
        (e2 = arguments[t]) && (o = r(e2)) && (f && (f += " "), f += o);
      return f;
    }
    module.exports = e, module.exports.clsx = e;
  }
});

// node_modules/date-fns/toDate.js
var require_toDate = __commonJS({
  "node_modules/date-fns/toDate.js"(exports) {
    "use strict";
    exports.toDate = toDate;
    function toDate(argument) {
      const argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
        return new argument.constructor(+argument);
      } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
        return new Date(argument);
      } else {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
  }
});

// node_modules/date-fns/constructFrom.js
var require_constructFrom = __commonJS({
  "node_modules/date-fns/constructFrom.js"(exports) {
    "use strict";
    exports.constructFrom = constructFrom;
    function constructFrom(date, value) {
      if (date instanceof Date) {
        return new date.constructor(value);
      } else {
        return new Date(value);
      }
    }
  }
});

// node_modules/date-fns/addDays.js
var require_addDays = __commonJS({
  "node_modules/date-fns/addDays.js"(exports) {
    "use strict";
    exports.addDays = addDays;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function addDays(date, amount) {
      const _date = (0, _index.toDate)(date);
      if (isNaN(amount))
        return (0, _index2.constructFrom)(date, NaN);
      if (!amount) {
        return _date;
      }
      _date.setDate(_date.getDate() + amount);
      return _date;
    }
  }
});

// node_modules/date-fns/addMilliseconds.js
var require_addMilliseconds = __commonJS({
  "node_modules/date-fns/addMilliseconds.js"(exports) {
    "use strict";
    exports.addMilliseconds = addMilliseconds;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function addMilliseconds(date, amount) {
      const timestamp = +(0, _index.toDate)(date);
      return (0, _index2.constructFrom)(date, timestamp + amount);
    }
  }
});

// node_modules/date-fns/constants.js
var require_constants = __commonJS({
  "node_modules/date-fns/constants.js"(exports) {
    "use strict";
    exports.secondsInYear = exports.secondsInWeek = exports.secondsInQuarter = exports.secondsInMonth = exports.secondsInMinute = exports.secondsInHour = exports.secondsInDay = exports.quartersInYear = exports.monthsInYear = exports.monthsInQuarter = exports.minutesInYear = exports.minutesInMonth = exports.minutesInHour = exports.minutesInDay = exports.minTime = exports.millisecondsInWeek = exports.millisecondsInSecond = exports.millisecondsInMinute = exports.millisecondsInHour = exports.millisecondsInDay = exports.maxTime = exports.daysInYear = exports.daysInWeek = void 0;
    var daysInWeek = exports.daysInWeek = 7;
    var daysInYear = exports.daysInYear = 365.2425;
    var maxTime = exports.maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
    var minTime = exports.minTime = -maxTime;
    var millisecondsInWeek = exports.millisecondsInWeek = 6048e5;
    var millisecondsInDay = exports.millisecondsInDay = 864e5;
    var millisecondsInMinute = exports.millisecondsInMinute = 6e4;
    var millisecondsInHour = exports.millisecondsInHour = 36e5;
    var millisecondsInSecond = exports.millisecondsInSecond = 1e3;
    var minutesInYear = exports.minutesInYear = 525600;
    var minutesInMonth = exports.minutesInMonth = 43200;
    var minutesInDay = exports.minutesInDay = 1440;
    var minutesInHour = exports.minutesInHour = 60;
    var monthsInQuarter = exports.monthsInQuarter = 3;
    var monthsInYear = exports.monthsInYear = 12;
    var quartersInYear = exports.quartersInYear = 4;
    var secondsInHour = exports.secondsInHour = 3600;
    var secondsInMinute = exports.secondsInMinute = 60;
    var secondsInDay = exports.secondsInDay = secondsInHour * 24;
    var secondsInWeek = exports.secondsInWeek = secondsInDay * 7;
    var secondsInYear = exports.secondsInYear = secondsInDay * daysInYear;
    var secondsInMonth = exports.secondsInMonth = secondsInYear / 12;
    var secondsInQuarter = exports.secondsInQuarter = secondsInMonth * 3;
  }
});

// node_modules/date-fns/addHours.js
var require_addHours = __commonJS({
  "node_modules/date-fns/addHours.js"(exports) {
    "use strict";
    exports.addHours = addHours;
    var _index = require_addMilliseconds();
    var _index2 = require_constants();
    function addHours(date, amount) {
      return (0, _index.addMilliseconds)(date, amount * _index2.millisecondsInHour);
    }
  }
});

// node_modules/date-fns/addMinutes.js
var require_addMinutes = __commonJS({
  "node_modules/date-fns/addMinutes.js"(exports) {
    "use strict";
    exports.addMinutes = addMinutes;
    var _index = require_addMilliseconds();
    var _index2 = require_constants();
    function addMinutes(date, amount) {
      return (0, _index.addMilliseconds)(
        date,
        amount * _index2.millisecondsInMinute
      );
    }
  }
});

// node_modules/date-fns/addMonths.js
var require_addMonths = __commonJS({
  "node_modules/date-fns/addMonths.js"(exports) {
    "use strict";
    exports.addMonths = addMonths;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function addMonths(date, amount) {
      const _date = (0, _index.toDate)(date);
      if (isNaN(amount))
        return (0, _index2.constructFrom)(date, NaN);
      if (!amount) {
        return _date;
      }
      const dayOfMonth = _date.getDate();
      const endOfDesiredMonth = (0, _index2.constructFrom)(date, _date.getTime());
      endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
      const daysInMonth = endOfDesiredMonth.getDate();
      if (dayOfMonth >= daysInMonth) {
        return endOfDesiredMonth;
      } else {
        _date.setFullYear(
          endOfDesiredMonth.getFullYear(),
          endOfDesiredMonth.getMonth(),
          dayOfMonth
        );
        return _date;
      }
    }
  }
});

// node_modules/date-fns/addQuarters.js
var require_addQuarters = __commonJS({
  "node_modules/date-fns/addQuarters.js"(exports) {
    "use strict";
    exports.addQuarters = addQuarters;
    var _index = require_addMonths();
    function addQuarters(date, amount) {
      const months = amount * 3;
      return (0, _index.addMonths)(date, months);
    }
  }
});

// node_modules/date-fns/addSeconds.js
var require_addSeconds = __commonJS({
  "node_modules/date-fns/addSeconds.js"(exports) {
    "use strict";
    exports.addSeconds = addSeconds;
    var _index = require_addMilliseconds();
    function addSeconds(date, amount) {
      return (0, _index.addMilliseconds)(date, amount * 1e3);
    }
  }
});

// node_modules/date-fns/addWeeks.js
var require_addWeeks = __commonJS({
  "node_modules/date-fns/addWeeks.js"(exports) {
    "use strict";
    exports.addWeeks = addWeeks;
    var _index = require_addDays();
    function addWeeks(date, amount) {
      const days = amount * 7;
      return (0, _index.addDays)(date, days);
    }
  }
});

// node_modules/date-fns/addYears.js
var require_addYears = __commonJS({
  "node_modules/date-fns/addYears.js"(exports) {
    "use strict";
    exports.addYears = addYears;
    var _index = require_addMonths();
    function addYears(date, amount) {
      return (0, _index.addMonths)(date, amount * 12);
    }
  }
});

// node_modules/date-fns/startOfDay.js
var require_startOfDay = __commonJS({
  "node_modules/date-fns/startOfDay.js"(exports) {
    "use strict";
    exports.startOfDay = startOfDay;
    var _index = require_toDate();
    function startOfDay(date) {
      const _date = (0, _index.toDate)(date);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
var require_getTimezoneOffsetInMilliseconds = __commonJS({
  "node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js"(exports) {
    "use strict";
    exports.getTimezoneOffsetInMilliseconds = getTimezoneOffsetInMilliseconds;
    var _index = require_toDate();
    function getTimezoneOffsetInMilliseconds(date) {
      const _date = (0, _index.toDate)(date);
      const utcDate = new Date(
        Date.UTC(
          _date.getFullYear(),
          _date.getMonth(),
          _date.getDate(),
          _date.getHours(),
          _date.getMinutes(),
          _date.getSeconds(),
          _date.getMilliseconds()
        )
      );
      utcDate.setUTCFullYear(_date.getFullYear());
      return +date - +utcDate;
    }
  }
});

// node_modules/date-fns/differenceInCalendarDays.js
var require_differenceInCalendarDays = __commonJS({
  "node_modules/date-fns/differenceInCalendarDays.js"(exports) {
    "use strict";
    exports.differenceInCalendarDays = differenceInCalendarDays;
    var _index = require_constants();
    var _index2 = require_startOfDay();
    var _index3 = require_getTimezoneOffsetInMilliseconds();
    function differenceInCalendarDays(dateLeft, dateRight) {
      const startOfDayLeft = (0, _index2.startOfDay)(dateLeft);
      const startOfDayRight = (0, _index2.startOfDay)(dateRight);
      const timestampLeft = +startOfDayLeft - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayLeft);
      const timestampRight = +startOfDayRight - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayRight);
      return Math.round(
        (timestampLeft - timestampRight) / _index.millisecondsInDay
      );
    }
  }
});

// node_modules/date-fns/differenceInCalendarMonths.js
var require_differenceInCalendarMonths = __commonJS({
  "node_modules/date-fns/differenceInCalendarMonths.js"(exports) {
    "use strict";
    exports.differenceInCalendarMonths = differenceInCalendarMonths;
    var _index = require_toDate();
    function differenceInCalendarMonths(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
      const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }
  }
});

// node_modules/date-fns/getQuarter.js
var require_getQuarter = __commonJS({
  "node_modules/date-fns/getQuarter.js"(exports) {
    "use strict";
    exports.getQuarter = getQuarter;
    var _index = require_toDate();
    function getQuarter(date) {
      const _date = (0, _index.toDate)(date);
      const quarter = Math.trunc(_date.getMonth() / 3) + 1;
      return quarter;
    }
  }
});

// node_modules/date-fns/differenceInCalendarQuarters.js
var require_differenceInCalendarQuarters = __commonJS({
  "node_modules/date-fns/differenceInCalendarQuarters.js"(exports) {
    "use strict";
    exports.differenceInCalendarQuarters = differenceInCalendarQuarters;
    var _index = require_getQuarter();
    var _index2 = require_toDate();
    function differenceInCalendarQuarters(dateLeft, dateRight) {
      const _dateLeft = (0, _index2.toDate)(dateLeft);
      const _dateRight = (0, _index2.toDate)(dateRight);
      const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
      const quarterDiff = (0, _index.getQuarter)(_dateLeft) - (0, _index.getQuarter)(_dateRight);
      return yearDiff * 4 + quarterDiff;
    }
  }
});

// node_modules/date-fns/differenceInCalendarYears.js
var require_differenceInCalendarYears = __commonJS({
  "node_modules/date-fns/differenceInCalendarYears.js"(exports) {
    "use strict";
    exports.differenceInCalendarYears = differenceInCalendarYears;
    var _index = require_toDate();
    function differenceInCalendarYears(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      return _dateLeft.getFullYear() - _dateRight.getFullYear();
    }
  }
});

// node_modules/date-fns/endOfDay.js
var require_endOfDay = __commonJS({
  "node_modules/date-fns/endOfDay.js"(exports) {
    "use strict";
    exports.endOfDay = endOfDay;
    var _index = require_toDate();
    function endOfDay(date) {
      const _date = (0, _index.toDate)(date);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/endOfMonth.js
var require_endOfMonth = __commonJS({
  "node_modules/date-fns/endOfMonth.js"(exports) {
    "use strict";
    exports.endOfMonth = endOfMonth;
    var _index = require_toDate();
    function endOfMonth(date) {
      const _date = (0, _index.toDate)(date);
      const month = _date.getMonth();
      _date.setFullYear(_date.getFullYear(), month + 1, 0);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/_lib/defaultOptions.js
var require_defaultOptions = __commonJS({
  "node_modules/date-fns/_lib/defaultOptions.js"(exports) {
    "use strict";
    exports.getDefaultOptions = getDefaultOptions;
    exports.setDefaultOptions = setDefaultOptions;
    var defaultOptions = {};
    function getDefaultOptions() {
      return defaultOptions;
    }
    function setDefaultOptions(newOptions) {
      defaultOptions = newOptions;
    }
  }
});

// node_modules/date-fns/endOfWeek.js
var require_endOfWeek = __commonJS({
  "node_modules/date-fns/endOfWeek.js"(exports) {
    "use strict";
    exports.endOfWeek = endOfWeek;
    var _index = require_toDate();
    var _index2 = require_defaultOptions();
    function endOfWeek(date, options) {
      var _a, _b, _c, _d;
      const defaultOptions = (0, _index2.getDefaultOptions)();
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
      const _date = (0, _index.toDate)(date);
      const day = _date.getDay();
      const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
      _date.setDate(_date.getDate() + diff);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/endOfYear.js
var require_endOfYear = __commonJS({
  "node_modules/date-fns/endOfYear.js"(exports) {
    "use strict";
    exports.endOfYear = endOfYear;
    var _index = require_toDate();
    function endOfYear(date) {
      const _date = (0, _index.toDate)(date);
      const year = _date.getFullYear();
      _date.setFullYear(year + 1, 0, 0);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
  }
});

// node_modules/date-fns/startOfYear.js
var require_startOfYear = __commonJS({
  "node_modules/date-fns/startOfYear.js"(exports) {
    "use strict";
    exports.startOfYear = startOfYear;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function startOfYear(date) {
      const cleanDate = (0, _index.toDate)(date);
      const _date = (0, _index2.constructFrom)(date, 0);
      _date.setFullYear(cleanDate.getFullYear(), 0, 1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/startOfWeek.js
var require_startOfWeek = __commonJS({
  "node_modules/date-fns/startOfWeek.js"(exports) {
    "use strict";
    exports.startOfWeek = startOfWeek;
    var _index = require_toDate();
    var _index2 = require_defaultOptions();
    function startOfWeek(date, options) {
      var _a, _b, _c, _d;
      const defaultOptions = (0, _index2.getDefaultOptions)();
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
      const _date = (0, _index.toDate)(date);
      const day = _date.getDay();
      const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      _date.setDate(_date.getDate() - diff);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/startOfISOWeek.js
var require_startOfISOWeek = __commonJS({
  "node_modules/date-fns/startOfISOWeek.js"(exports) {
    "use strict";
    exports.startOfISOWeek = startOfISOWeek;
    var _index = require_startOfWeek();
    function startOfISOWeek(date) {
      return (0, _index.startOfWeek)(date, { weekStartsOn: 1 });
    }
  }
});

// node_modules/date-fns/getISOWeekYear.js
var require_getISOWeekYear = __commonJS({
  "node_modules/date-fns/getISOWeekYear.js"(exports) {
    "use strict";
    exports.getISOWeekYear = getISOWeekYear;
    var _index = require_constructFrom();
    var _index2 = require_startOfISOWeek();
    var _index3 = require_toDate();
    function getISOWeekYear(date) {
      const _date = (0, _index3.toDate)(date);
      const year = _date.getFullYear();
      const fourthOfJanuaryOfNextYear = (0, _index.constructFrom)(date, 0);
      fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
      const startOfNextYear = (0, _index2.startOfISOWeek)(
        fourthOfJanuaryOfNextYear
      );
      const fourthOfJanuaryOfThisYear = (0, _index.constructFrom)(date, 0);
      fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
      const startOfThisYear = (0, _index2.startOfISOWeek)(
        fourthOfJanuaryOfThisYear
      );
      if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
  }
});

// node_modules/date-fns/startOfISOWeekYear.js
var require_startOfISOWeekYear = __commonJS({
  "node_modules/date-fns/startOfISOWeekYear.js"(exports) {
    "use strict";
    exports.startOfISOWeekYear = startOfISOWeekYear;
    var _index = require_getISOWeekYear();
    var _index2 = require_startOfISOWeek();
    var _index3 = require_constructFrom();
    function startOfISOWeekYear(date) {
      const year = (0, _index.getISOWeekYear)(date);
      const fourthOfJanuary = (0, _index3.constructFrom)(date, 0);
      fourthOfJanuary.setFullYear(year, 0, 4);
      fourthOfJanuary.setHours(0, 0, 0, 0);
      return (0, _index2.startOfISOWeek)(fourthOfJanuary);
    }
  }
});

// node_modules/date-fns/getISOWeek.js
var require_getISOWeek = __commonJS({
  "node_modules/date-fns/getISOWeek.js"(exports) {
    "use strict";
    exports.getISOWeek = getISOWeek;
    var _index = require_constants();
    var _index2 = require_startOfISOWeek();
    var _index3 = require_startOfISOWeekYear();
    var _index4 = require_toDate();
    function getISOWeek(date) {
      const _date = (0, _index4.toDate)(date);
      const diff = +(0, _index2.startOfISOWeek)(_date) - +(0, _index3.startOfISOWeekYear)(_date);
      return Math.round(diff / _index.millisecondsInWeek) + 1;
    }
  }
});

// node_modules/date-fns/isDate.js
var require_isDate = __commonJS({
  "node_modules/date-fns/isDate.js"(exports) {
    "use strict";
    exports.isDate = isDate;
    function isDate(value) {
      return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
    }
  }
});

// node_modules/date-fns/isValid.js
var require_isValid = __commonJS({
  "node_modules/date-fns/isValid.js"(exports) {
    "use strict";
    exports.isValid = isValid;
    var _index = require_isDate();
    var _index2 = require_toDate();
    function isValid(date) {
      if (!(0, _index.isDate)(date) && typeof date !== "number") {
        return false;
      }
      const _date = (0, _index2.toDate)(date);
      return !isNaN(Number(_date));
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var require_formatDistance = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatDistance.js"(exports) {
    "use strict";
    exports.formatDistance = void 0;
    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    var formatDistance = (token, count2, options) => {
      let result;
      const tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count2 === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count2.toString());
      }
      if (options == null ? void 0 : options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    exports.formatDistance = formatDistance;
  }
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn.js
var require_buildFormatLongFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildFormatLongFn.js"(exports) {
    "use strict";
    exports.buildFormatLongFn = buildFormatLongFn;
    function buildFormatLongFn(args) {
      return (options = {}) => {
        const width = options.width ? String(options.width) : args.defaultWidth;
        const format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatLong.js
var require_formatLong = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatLong.js"(exports) {
    "use strict";
    exports.formatLong = void 0;
    var _index = require_buildFormatLongFn();
    var dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    var timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    var formatLong = exports.formatLong = {
      date: (0, _index.buildFormatLongFn)({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: (0, _index.buildFormatLongFn)({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: (0, _index.buildFormatLongFn)({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var require_formatRelative = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatRelative.js"(exports) {
    "use strict";
    exports.formatRelative = void 0;
    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
    exports.formatRelative = formatRelative;
  }
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn.js
var require_buildLocalizeFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildLocalizeFn.js"(exports) {
    "use strict";
    exports.buildLocalizeFn = buildLocalizeFn;
    function buildLocalizeFn(args) {
      return (value, options) => {
        const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
        let valuesArray;
        if (context === "formatting" && args.formattingValues) {
          const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          const defaultWidth = args.defaultWidth;
          const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[width] || args.values[defaultWidth];
        }
        const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
        return valuesArray[index2];
      };
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/localize.js
var require_localize = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/localize.js"(exports) {
    "use strict";
    exports.localize = void 0;
    var _index = require_buildLocalizeFn();
    var eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    var quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    var monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    };
    var dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    };
    var dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    var ordinalNumber = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      const rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    var localize = exports.localize = {
      ordinalNumber,
      era: (0, _index.buildLocalizeFn)({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: (0, _index.buildLocalizeFn)({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: (0, _index.buildLocalizeFn)({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: (0, _index.buildLocalizeFn)({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: (0, _index.buildLocalizeFn)({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
  }
});

// node_modules/date-fns/locale/_lib/buildMatchFn.js
var require_buildMatchFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchFn.js"(exports) {
    "use strict";
    exports.buildMatchFn = buildMatchFn;
    function buildMatchFn(args) {
      return (string, options = {}) => {
        const width = options.width;
        const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        const matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        const matchedString = matchResult[0];
        const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          findKey(parsePatterns, (pattern) => pattern.test(matchedString))
        );
        let value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          options.valueCallback(value)
        ) : value;
        const rest = string.slice(matchedString.length);
        return { value, rest };
      };
    }
    function findKey(object, predicate) {
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
          return key;
        }
      }
      return void 0;
    }
    function findIndex(array, predicate) {
      for (let key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
      return void 0;
    }
  }
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
var require_buildMatchPatternFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchPatternFn.js"(exports) {
    "use strict";
    exports.buildMatchPatternFn = buildMatchPatternFn;
    function buildMatchPatternFn(args) {
      return (string, options = {}) => {
        const matchResult = string.match(args.matchPattern);
        if (!matchResult)
          return null;
        const matchedString = matchResult[0];
        const parseResult = string.match(args.parsePattern);
        if (!parseResult)
          return null;
        let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return { value, rest };
      };
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/match.js
var require_match = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/match.js"(exports) {
    "use strict";
    exports.match = void 0;
    var _index = require_buildMatchFn();
    var _index2 = require_buildMatchPatternFn();
    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = exports.match = {
      ordinalNumber: (0, _index2.buildMatchPatternFn)({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: (value) => parseInt(value, 10)
      }),
      era: (0, _index.buildMatchFn)({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: (0, _index.buildMatchFn)({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: (0, _index.buildMatchFn)({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: (0, _index.buildMatchFn)({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: (0, _index.buildMatchFn)({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
  }
});

// node_modules/date-fns/locale/en-US.js
var require_en_US = __commonJS({
  "node_modules/date-fns/locale/en-US.js"(exports) {
    "use strict";
    exports.enUS = void 0;
    var _index = require_formatDistance();
    var _index2 = require_formatLong();
    var _index3 = require_formatRelative();
    var _index4 = require_localize();
    var _index5 = require_match();
    var enUS = exports.enUS = {
      code: "en-US",
      formatDistance: _index.formatDistance,
      formatLong: _index2.formatLong,
      formatRelative: _index3.formatRelative,
      localize: _index4.localize,
      match: _index5.match,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
  }
});

// node_modules/date-fns/_lib/defaultLocale.js
var require_defaultLocale = __commonJS({
  "node_modules/date-fns/_lib/defaultLocale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "defaultLocale", {
      enumerable: true,
      get: function() {
        return _index.enUS;
      }
    });
    var _index = require_en_US();
  }
});

// node_modules/date-fns/getDayOfYear.js
var require_getDayOfYear = __commonJS({
  "node_modules/date-fns/getDayOfYear.js"(exports) {
    "use strict";
    exports.getDayOfYear = getDayOfYear;
    var _index = require_differenceInCalendarDays();
    var _index2 = require_startOfYear();
    var _index3 = require_toDate();
    function getDayOfYear(date) {
      const _date = (0, _index3.toDate)(date);
      const diff = (0, _index.differenceInCalendarDays)(
        _date,
        (0, _index2.startOfYear)(_date)
      );
      const dayOfYear = diff + 1;
      return dayOfYear;
    }
  }
});

// node_modules/date-fns/getWeekYear.js
var require_getWeekYear = __commonJS({
  "node_modules/date-fns/getWeekYear.js"(exports) {
    "use strict";
    exports.getWeekYear = getWeekYear;
    var _index = require_constructFrom();
    var _index2 = require_startOfWeek();
    var _index3 = require_toDate();
    var _index4 = require_defaultOptions();
    function getWeekYear(date, options) {
      var _a, _b, _c, _d;
      const _date = (0, _index3.toDate)(date);
      const year = _date.getFullYear();
      const defaultOptions = (0, _index4.getDefaultOptions)();
      const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
      const firstWeekOfNextYear = (0, _index.constructFrom)(date, 0);
      firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setHours(0, 0, 0, 0);
      const startOfNextYear = (0, _index2.startOfWeek)(
        firstWeekOfNextYear,
        options
      );
      const firstWeekOfThisYear = (0, _index.constructFrom)(date, 0);
      firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setHours(0, 0, 0, 0);
      const startOfThisYear = (0, _index2.startOfWeek)(
        firstWeekOfThisYear,
        options
      );
      if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
  }
});

// node_modules/date-fns/startOfWeekYear.js
var require_startOfWeekYear = __commonJS({
  "node_modules/date-fns/startOfWeekYear.js"(exports) {
    "use strict";
    exports.startOfWeekYear = startOfWeekYear;
    var _index = require_constructFrom();
    var _index2 = require_getWeekYear();
    var _index3 = require_startOfWeek();
    var _index4 = require_defaultOptions();
    function startOfWeekYear(date, options) {
      var _a, _b, _c, _d;
      const defaultOptions = (0, _index4.getDefaultOptions)();
      const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
      const year = (0, _index2.getWeekYear)(date, options);
      const firstWeek = (0, _index.constructFrom)(date, 0);
      firstWeek.setFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setHours(0, 0, 0, 0);
      const _date = (0, _index3.startOfWeek)(firstWeek, options);
      return _date;
    }
  }
});

// node_modules/date-fns/getWeek.js
var require_getWeek = __commonJS({
  "node_modules/date-fns/getWeek.js"(exports) {
    "use strict";
    exports.getWeek = getWeek;
    var _index = require_constants();
    var _index2 = require_startOfWeek();
    var _index3 = require_startOfWeekYear();
    var _index4 = require_toDate();
    function getWeek(date, options) {
      const _date = (0, _index4.toDate)(date);
      const diff = +(0, _index2.startOfWeek)(_date, options) - +(0, _index3.startOfWeekYear)(_date, options);
      return Math.round(diff / _index.millisecondsInWeek) + 1;
    }
  }
});

// node_modules/date-fns/_lib/addLeadingZeros.js
var require_addLeadingZeros = __commonJS({
  "node_modules/date-fns/_lib/addLeadingZeros.js"(exports) {
    "use strict";
    exports.addLeadingZeros = addLeadingZeros;
    function addLeadingZeros(number, targetLength) {
      const sign = number < 0 ? "-" : "";
      const output = Math.abs(number).toString().padStart(targetLength, "0");
      return sign + output;
    }
  }
});

// node_modules/date-fns/_lib/format/lightFormatters.js
var require_lightFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/lightFormatters.js"(exports) {
    "use strict";
    exports.lightFormatters = void 0;
    var _index = require_addLeadingZeros();
    var lightFormatters = exports.lightFormatters = {
      // Year
      y(date, token) {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return (0, _index.addLeadingZeros)(
          token === "yy" ? year % 100 : year,
          token.length
        );
      },
      // Month
      M(date, token) {
        const month = date.getMonth();
        return token === "M" ? String(month + 1) : (0, _index.addLeadingZeros)(month + 1, 2);
      },
      // Day of the month
      d(date, token) {
        return (0, _index.addLeadingZeros)(date.getDate(), token.length);
      },
      // AM or PM
      a(date, token) {
        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h(date, token) {
        return (0, _index.addLeadingZeros)(
          date.getHours() % 12 || 12,
          token.length
        );
      },
      // Hour [0-23]
      H(date, token) {
        return (0, _index.addLeadingZeros)(date.getHours(), token.length);
      },
      // Minute
      m(date, token) {
        return (0, _index.addLeadingZeros)(date.getMinutes(), token.length);
      },
      // Second
      s(date, token) {
        return (0, _index.addLeadingZeros)(date.getSeconds(), token.length);
      },
      // Fraction of second
      S(date, token) {
        const numberOfDigits = token.length;
        const milliseconds = date.getMilliseconds();
        const fractionalSeconds = Math.trunc(
          milliseconds * Math.pow(10, numberOfDigits - 3)
        );
        return (0, _index.addLeadingZeros)(fractionalSeconds, token.length);
      }
    };
  }
});

// node_modules/date-fns/_lib/format/formatters.js
var require_formatters = __commonJS({
  "node_modules/date-fns/_lib/format/formatters.js"(exports) {
    "use strict";
    exports.formatters = void 0;
    var _index = require_getDayOfYear();
    var _index2 = require_getISOWeek();
    var _index3 = require_getISOWeekYear();
    var _index4 = require_getWeek();
    var _index5 = require_getWeekYear();
    var _index6 = require_addLeadingZeros();
    var _index7 = require_lightFormatters();
    var dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    var formatters = exports.formatters = {
      // Era
      G: function(date, token, localize) {
        const era = date.getFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize.era(era, { width: "abbreviated" });
          case "GGGGG":
            return localize.era(era, { width: "narrow" });
          case "GGGG":
          default:
            return localize.era(era, { width: "wide" });
        }
      },
      // Year
      y: function(date, token, localize) {
        if (token === "yo") {
          const signedYear = date.getFullYear();
          const year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, { unit: "year" });
        }
        return _index7.lightFormatters.y(date, token);
      },
      // Local week-numbering year
      Y: function(date, token, localize, options) {
        const signedWeekYear = (0, _index5.getWeekYear)(date, options);
        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          const twoDigitYear = weekYear % 100;
          return (0, _index6.addLeadingZeros)(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize.ordinalNumber(weekYear, { unit: "year" });
        }
        return (0, _index6.addLeadingZeros)(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function(date, token) {
        const isoWeekYear = (0, _index3.getISOWeekYear)(date);
        return (0, _index6.addLeadingZeros)(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function(date, token) {
        const year = date.getFullYear();
        return (0, _index6.addLeadingZeros)(year, token.length);
      },
      // Quarter
      Q: function(date, token, localize) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return (0, _index6.addLeadingZeros)(quarter, 2);
          case "Qo":
            return localize.ordinalNumber(quarter, { unit: "quarter" });
          case "QQQ":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function(date, token, localize) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return (0, _index6.addLeadingZeros)(quarter, 2);
          case "qo":
            return localize.ordinalNumber(quarter, { unit: "quarter" });
          case "qqq":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function(date, token, localize) {
        const month = date.getMonth();
        switch (token) {
          case "M":
          case "MM":
            return _index7.lightFormatters.M(date, token);
          case "Mo":
            return localize.ordinalNumber(month + 1, { unit: "month" });
          case "MMM":
            return localize.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize.month(month, { width: "wide", context: "formatting" });
        }
      },
      // Stand-alone month
      L: function(date, token, localize) {
        const month = date.getMonth();
        switch (token) {
          case "L":
            return String(month + 1);
          case "LL":
            return (0, _index6.addLeadingZeros)(month + 1, 2);
          case "Lo":
            return localize.ordinalNumber(month + 1, { unit: "month" });
          case "LLL":
            return localize.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize.month(month, { width: "wide", context: "standalone" });
        }
      },
      // Local week of year
      w: function(date, token, localize, options) {
        const week = (0, _index4.getWeek)(date, options);
        if (token === "wo") {
          return localize.ordinalNumber(week, { unit: "week" });
        }
        return (0, _index6.addLeadingZeros)(week, token.length);
      },
      // ISO week of year
      I: function(date, token, localize) {
        const isoWeek = (0, _index2.getISOWeek)(date);
        if (token === "Io") {
          return localize.ordinalNumber(isoWeek, { unit: "week" });
        }
        return (0, _index6.addLeadingZeros)(isoWeek, token.length);
      },
      // Day of the month
      d: function(date, token, localize) {
        if (token === "do") {
          return localize.ordinalNumber(date.getDate(), { unit: "date" });
        }
        return _index7.lightFormatters.d(date, token);
      },
      // Day of year
      D: function(date, token, localize) {
        const dayOfYear = (0, _index.getDayOfYear)(date);
        if (token === "Do") {
          return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
        }
        return (0, _index6.addLeadingZeros)(dayOfYear, token.length);
      },
      // Day of week
      E: function(date, token, localize) {
        const dayOfWeek = date.getDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function(date, token, localize, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return (0, _index6.addLeadingZeros)(localDayOfWeek, 2);
          case "eo":
            return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "eee":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function(date, token, localize, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return (0, _index6.addLeadingZeros)(localDayOfWeek, token.length);
          case "co":
            return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "ccc":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function(date, token, localize) {
        const dayOfWeek = date.getDay();
        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return (0, _index6.addLeadingZeros)(isoDayOfWeek, token.length);
          case "io":
            return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
          case "iii":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function(date, token, localize) {
        const hours = date.getHours();
        const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function(date, token, localize) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function(date, token, localize) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function(date, token, localize) {
        if (token === "ho") {
          let hours = date.getHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize.ordinalNumber(hours, { unit: "hour" });
        }
        return _index7.lightFormatters.h(date, token);
      },
      // Hour [0-23]
      H: function(date, token, localize) {
        if (token === "Ho") {
          return localize.ordinalNumber(date.getHours(), { unit: "hour" });
        }
        return _index7.lightFormatters.H(date, token);
      },
      // Hour [0-11]
      K: function(date, token, localize) {
        const hours = date.getHours() % 12;
        if (token === "Ko") {
          return localize.ordinalNumber(hours, { unit: "hour" });
        }
        return (0, _index6.addLeadingZeros)(hours, token.length);
      },
      // Hour [1-24]
      k: function(date, token, localize) {
        let hours = date.getHours();
        if (hours === 0)
          hours = 24;
        if (token === "ko") {
          return localize.ordinalNumber(hours, { unit: "hour" });
        }
        return (0, _index6.addLeadingZeros)(hours, token.length);
      },
      // Minute
      m: function(date, token, localize) {
        if (token === "mo") {
          return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
        }
        return _index7.lightFormatters.m(date, token);
      },
      // Second
      s: function(date, token, localize) {
        if (token === "so") {
          return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
        }
        return _index7.lightFormatters.s(date, token);
      },
      // Fraction of second
      S: function(date, token) {
        return _index7.lightFormatters.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function(date, token, _localize) {
        const timestamp = Math.trunc(date.getTime() / 1e3);
        return (0, _index6.addLeadingZeros)(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function(date, token, _localize) {
        const timestamp = date.getTime();
        return (0, _index6.addLeadingZeros)(timestamp, token.length);
      }
    };
    function formatTimezoneShort(offset2, delimiter = "") {
      const sign = offset2 > 0 ? "-" : "+";
      const absOffset = Math.abs(offset2);
      const hours = Math.trunc(absOffset / 60);
      const minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      return sign + String(hours) + delimiter + (0, _index6.addLeadingZeros)(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes(offset2, delimiter) {
      if (offset2 % 60 === 0) {
        const sign = offset2 > 0 ? "-" : "+";
        return sign + (0, _index6.addLeadingZeros)(Math.abs(offset2) / 60, 2);
      }
      return formatTimezone(offset2, delimiter);
    }
    function formatTimezone(offset2, delimiter = "") {
      const sign = offset2 > 0 ? "-" : "+";
      const absOffset = Math.abs(offset2);
      const hours = (0, _index6.addLeadingZeros)(Math.trunc(absOffset / 60), 2);
      const minutes = (0, _index6.addLeadingZeros)(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }
  }
});

// node_modules/date-fns/_lib/format/longFormatters.js
var require_longFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/longFormatters.js"(exports) {
    "use strict";
    exports.longFormatters = void 0;
    var dateLongFormatter = (pattern, formatLong) => {
      switch (pattern) {
        case "P":
          return formatLong.date({ width: "short" });
        case "PP":
          return formatLong.date({ width: "medium" });
        case "PPP":
          return formatLong.date({ width: "long" });
        case "PPPP":
        default:
          return formatLong.date({ width: "full" });
      }
    };
    var timeLongFormatter = (pattern, formatLong) => {
      switch (pattern) {
        case "p":
          return formatLong.time({ width: "short" });
        case "pp":
          return formatLong.time({ width: "medium" });
        case "ppp":
          return formatLong.time({ width: "long" });
        case "pppp":
        default:
          return formatLong.time({ width: "full" });
      }
    };
    var dateTimeLongFormatter = (pattern, formatLong) => {
      const matchResult = pattern.match(/(P+)(p+)?/) || [];
      const datePattern = matchResult[1];
      const timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }
      let dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong.dateTime({ width: "short" });
          break;
        case "PP":
          dateTimeFormat = formatLong.dateTime({ width: "medium" });
          break;
        case "PPP":
          dateTimeFormat = formatLong.dateTime({ width: "long" });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong.dateTime({ width: "full" });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
    };
    var longFormatters = exports.longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
  }
});

// node_modules/date-fns/_lib/protectedTokens.js
var require_protectedTokens = __commonJS({
  "node_modules/date-fns/_lib/protectedTokens.js"(exports) {
    "use strict";
    exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
    exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
    exports.warnOrThrowProtectedError = warnOrThrowProtectedError;
    var dayOfYearTokenRE = /^D+$/;
    var weekYearTokenRE = /^Y+$/;
    var throwTokens = ["D", "DD", "YY", "YYYY"];
    function isProtectedDayOfYearToken(token) {
      return dayOfYearTokenRE.test(token);
    }
    function isProtectedWeekYearToken(token) {
      return weekYearTokenRE.test(token);
    }
    function warnOrThrowProtectedError(token, format, input) {
      const _message = message(token, format, input);
      console.warn(_message);
      if (throwTokens.includes(token))
        throw new RangeError(_message);
    }
    function message(token, format, input) {
      const subject = token[0] === "Y" ? "years" : "days of the month";
      return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
    }
  }
});

// node_modules/date-fns/format.js
var require_format = __commonJS({
  "node_modules/date-fns/format.js"(exports) {
    "use strict";
    exports.format = exports.formatDate = format;
    Object.defineProperty(exports, "formatters", {
      enumerable: true,
      get: function() {
        return _index3.formatters;
      }
    });
    Object.defineProperty(exports, "longFormatters", {
      enumerable: true,
      get: function() {
        return _index4.longFormatters;
      }
    });
    var _index = require_defaultLocale();
    var _index2 = require_defaultOptions();
    var _index3 = require_formatters();
    var _index4 = require_longFormatters();
    var _index5 = require_protectedTokens();
    var _index6 = require_isValid();
    var _index7 = require_toDate();
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function format(date, formatStr, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const defaultOptions = (0, _index2.getDefaultOptions)();
      const locale = (options == null ? void 0 : options.locale) ?? defaultOptions.locale ?? _index.defaultLocale;
      const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_h = (_g = defaultOptions.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
      const originalDate = (0, _index7.toDate)(date);
      if (!(0, _index6.isValid)(originalDate)) {
        throw new RangeError("Invalid time value");
      }
      let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          const longFormatter = _index4.longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp).map((substring) => {
        if (substring === "''") {
          return { isToken: false, value: "'" };
        }
        const firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return { isToken: false, value: cleanEscapedString(substring) };
        }
        if (_index3.formatters[firstCharacter]) {
          return { isToken: true, value: substring };
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
          );
        }
        return { isToken: false, value: substring };
      });
      if (locale.localize.preprocessor) {
        parts = locale.localize.preprocessor(originalDate, parts);
      }
      const formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
      };
      return parts.map((part) => {
        if (!part.isToken)
          return part.value;
        const token = part.value;
        if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && (0, _index5.isProtectedWeekYearToken)(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && (0, _index5.isProtectedDayOfYearToken)(token)) {
          (0, _index5.warnOrThrowProtectedError)(token, formatStr, String(date));
        }
        const formatter = _index3.formatters[token[0]];
        return formatter(originalDate, token, locale.localize, formatterOptions);
      }).join("");
    }
    function cleanEscapedString(input) {
      const matched = input.match(escapedStringRegExp);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp, "'");
    }
  }
});

// node_modules/date-fns/getDate.js
var require_getDate = __commonJS({
  "node_modules/date-fns/getDate.js"(exports) {
    "use strict";
    exports.getDate = getDate;
    var _index = require_toDate();
    function getDate(date) {
      const _date = (0, _index.toDate)(date);
      const dayOfMonth = _date.getDate();
      return dayOfMonth;
    }
  }
});

// node_modules/date-fns/getDay.js
var require_getDay = __commonJS({
  "node_modules/date-fns/getDay.js"(exports) {
    "use strict";
    exports.getDay = getDay;
    var _index = require_toDate();
    function getDay(date) {
      const _date = (0, _index.toDate)(date);
      const day = _date.getDay();
      return day;
    }
  }
});

// node_modules/date-fns/getHours.js
var require_getHours = __commonJS({
  "node_modules/date-fns/getHours.js"(exports) {
    "use strict";
    exports.getHours = getHours;
    var _index = require_toDate();
    function getHours(date) {
      const _date = (0, _index.toDate)(date);
      const hours = _date.getHours();
      return hours;
    }
  }
});

// node_modules/date-fns/getMinutes.js
var require_getMinutes = __commonJS({
  "node_modules/date-fns/getMinutes.js"(exports) {
    "use strict";
    exports.getMinutes = getMinutes;
    var _index = require_toDate();
    function getMinutes(date) {
      const _date = (0, _index.toDate)(date);
      const minutes = _date.getMinutes();
      return minutes;
    }
  }
});

// node_modules/date-fns/getMonth.js
var require_getMonth = __commonJS({
  "node_modules/date-fns/getMonth.js"(exports) {
    "use strict";
    exports.getMonth = getMonth;
    var _index = require_toDate();
    function getMonth(date) {
      const _date = (0, _index.toDate)(date);
      const month = _date.getMonth();
      return month;
    }
  }
});

// node_modules/date-fns/getSeconds.js
var require_getSeconds = __commonJS({
  "node_modules/date-fns/getSeconds.js"(exports) {
    "use strict";
    exports.getSeconds = getSeconds;
    var _index = require_toDate();
    function getSeconds(date) {
      const _date = (0, _index.toDate)(date);
      const seconds = _date.getSeconds();
      return seconds;
    }
  }
});

// node_modules/date-fns/getTime.js
var require_getTime = __commonJS({
  "node_modules/date-fns/getTime.js"(exports) {
    "use strict";
    exports.getTime = getTime;
    var _index = require_toDate();
    function getTime(date) {
      const _date = (0, _index.toDate)(date);
      const timestamp = _date.getTime();
      return timestamp;
    }
  }
});

// node_modules/date-fns/getYear.js
var require_getYear = __commonJS({
  "node_modules/date-fns/getYear.js"(exports) {
    "use strict";
    exports.getYear = getYear;
    var _index = require_toDate();
    function getYear(date) {
      return (0, _index.toDate)(date).getFullYear();
    }
  }
});

// node_modules/date-fns/isAfter.js
var require_isAfter = __commonJS({
  "node_modules/date-fns/isAfter.js"(exports) {
    "use strict";
    exports.isAfter = isAfter;
    var _index = require_toDate();
    function isAfter(date, dateToCompare) {
      const _date = (0, _index.toDate)(date);
      const _dateToCompare = (0, _index.toDate)(dateToCompare);
      return _date.getTime() > _dateToCompare.getTime();
    }
  }
});

// node_modules/date-fns/isBefore.js
var require_isBefore = __commonJS({
  "node_modules/date-fns/isBefore.js"(exports) {
    "use strict";
    exports.isBefore = isBefore;
    var _index = require_toDate();
    function isBefore(date, dateToCompare) {
      const _date = (0, _index.toDate)(date);
      const _dateToCompare = (0, _index.toDate)(dateToCompare);
      return +_date < +_dateToCompare;
    }
  }
});

// node_modules/date-fns/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/date-fns/isEqual.js"(exports) {
    "use strict";
    exports.isEqual = isEqual;
    var _index = require_toDate();
    function isEqual(leftDate, rightDate) {
      const _dateLeft = (0, _index.toDate)(leftDate);
      const _dateRight = (0, _index.toDate)(rightDate);
      return +_dateLeft === +_dateRight;
    }
  }
});

// node_modules/date-fns/isSameDay.js
var require_isSameDay = __commonJS({
  "node_modules/date-fns/isSameDay.js"(exports) {
    "use strict";
    exports.isSameDay = isSameDay;
    var _index = require_startOfDay();
    function isSameDay(dateLeft, dateRight) {
      const dateLeftStartOfDay = (0, _index.startOfDay)(dateLeft);
      const dateRightStartOfDay = (0, _index.startOfDay)(dateRight);
      return +dateLeftStartOfDay === +dateRightStartOfDay;
    }
  }
});

// node_modules/date-fns/isSameMonth.js
var require_isSameMonth = __commonJS({
  "node_modules/date-fns/isSameMonth.js"(exports) {
    "use strict";
    exports.isSameMonth = isSameMonth;
    var _index = require_toDate();
    function isSameMonth(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
    }
  }
});

// node_modules/date-fns/startOfQuarter.js
var require_startOfQuarter = __commonJS({
  "node_modules/date-fns/startOfQuarter.js"(exports) {
    "use strict";
    exports.startOfQuarter = startOfQuarter;
    var _index = require_toDate();
    function startOfQuarter(date) {
      const _date = (0, _index.toDate)(date);
      const currentMonth = _date.getMonth();
      const month = currentMonth - currentMonth % 3;
      _date.setMonth(month, 1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/isSameQuarter.js
var require_isSameQuarter = __commonJS({
  "node_modules/date-fns/isSameQuarter.js"(exports) {
    "use strict";
    exports.isSameQuarter = isSameQuarter;
    var _index = require_startOfQuarter();
    function isSameQuarter(dateLeft, dateRight) {
      const dateLeftStartOfQuarter = (0, _index.startOfQuarter)(dateLeft);
      const dateRightStartOfQuarter = (0, _index.startOfQuarter)(dateRight);
      return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
    }
  }
});

// node_modules/date-fns/isSameYear.js
var require_isSameYear = __commonJS({
  "node_modules/date-fns/isSameYear.js"(exports) {
    "use strict";
    exports.isSameYear = isSameYear;
    var _index = require_toDate();
    function isSameYear(dateLeft, dateRight) {
      const _dateLeft = (0, _index.toDate)(dateLeft);
      const _dateRight = (0, _index.toDate)(dateRight);
      return _dateLeft.getFullYear() === _dateRight.getFullYear();
    }
  }
});

// node_modules/date-fns/isWithinInterval.js
var require_isWithinInterval = __commonJS({
  "node_modules/date-fns/isWithinInterval.js"(exports) {
    "use strict";
    exports.isWithinInterval = isWithinInterval;
    var _index = require_toDate();
    function isWithinInterval(date, interval) {
      const time = +(0, _index.toDate)(date);
      const [startTime, endTime] = [
        +(0, _index.toDate)(interval.start),
        +(0, _index.toDate)(interval.end)
      ].sort((a, b) => a - b);
      return time >= startTime && time <= endTime;
    }
  }
});

// node_modules/date-fns/max.js
var require_max = __commonJS({
  "node_modules/date-fns/max.js"(exports) {
    "use strict";
    exports.max = max2;
    var _index = require_toDate();
    function max2(dates) {
      let result;
      dates.forEach(function(dirtyDate) {
        const currentDate = (0, _index.toDate)(dirtyDate);
        if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
          result = currentDate;
        }
      });
      return result || /* @__PURE__ */ new Date(NaN);
    }
  }
});

// node_modules/date-fns/min.js
var require_min = __commonJS({
  "node_modules/date-fns/min.js"(exports) {
    "use strict";
    exports.min = min;
    var _index = require_toDate();
    function min(dates) {
      let result;
      dates.forEach((dirtyDate) => {
        const date = (0, _index.toDate)(dirtyDate);
        if (!result || result > date || isNaN(+date)) {
          result = date;
        }
      });
      return result || /* @__PURE__ */ new Date(NaN);
    }
  }
});

// node_modules/date-fns/getDefaultOptions.js
var require_getDefaultOptions = __commonJS({
  "node_modules/date-fns/getDefaultOptions.js"(exports) {
    "use strict";
    exports.getDefaultOptions = getDefaultOptions;
    var _index = require_defaultOptions();
    function getDefaultOptions() {
      return Object.assign({}, (0, _index.getDefaultOptions)());
    }
  }
});

// node_modules/date-fns/transpose.js
var require_transpose = __commonJS({
  "node_modules/date-fns/transpose.js"(exports) {
    "use strict";
    exports.transpose = transpose;
    var _index = require_constructFrom();
    function transpose(fromDate, constructor) {
      const date = constructor instanceof Date ? (0, _index.constructFrom)(constructor, 0) : new constructor(0);
      date.setFullYear(
        fromDate.getFullYear(),
        fromDate.getMonth(),
        fromDate.getDate()
      );
      date.setHours(
        fromDate.getHours(),
        fromDate.getMinutes(),
        fromDate.getSeconds(),
        fromDate.getMilliseconds()
      );
      return date;
    }
  }
});

// node_modules/date-fns/parse/_lib/Setter.js
var require_Setter = __commonJS({
  "node_modules/date-fns/parse/_lib/Setter.js"(exports) {
    "use strict";
    exports.ValueSetter = exports.Setter = exports.DateToSystemTimezoneSetter = void 0;
    var _index = require_transpose();
    var _index2 = require_constructFrom();
    var TIMEZONE_UNIT_PRIORITY = 10;
    var Setter = class {
      constructor() {
        __publicField(this, "subPriority", 0);
      }
      validate(_utcDate, _options) {
        return true;
      }
    };
    exports.Setter = Setter;
    var ValueSetter = class extends Setter {
      constructor(value, validateValue, setValue, priority, subPriority) {
        super();
        this.value = value;
        this.validateValue = validateValue;
        this.setValue = setValue;
        this.priority = priority;
        if (subPriority) {
          this.subPriority = subPriority;
        }
      }
      validate(date, options) {
        return this.validateValue(date, this.value, options);
      }
      set(date, flags, options) {
        return this.setValue(date, flags, this.value, options);
      }
    };
    exports.ValueSetter = ValueSetter;
    var DateToSystemTimezoneSetter = class extends Setter {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
        __publicField(this, "subPriority", -1);
      }
      set(date, flags) {
        if (flags.timestampIsSet)
          return date;
        return (0, _index2.constructFrom)(date, (0, _index.transpose)(date, Date));
      }
    };
    exports.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;
  }
});

// node_modules/date-fns/parse/_lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/Parser.js"(exports) {
    "use strict";
    exports.Parser = void 0;
    var _Setter = require_Setter();
    var Parser = class {
      run(dateString, token, match, options) {
        const result = this.parse(dateString, token, match, options);
        if (!result) {
          return null;
        }
        return {
          setter: new _Setter.ValueSetter(
            result.value,
            this.validate,
            this.set,
            this.priority,
            this.subPriority
          ),
          rest: result.rest
        };
      }
      validate(_utcDate, _value, _options) {
        return true;
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/EraParser.js
var require_EraParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/EraParser.js"(exports) {
    "use strict";
    exports.EraParser = void 0;
    var _Parser = require_Parser();
    var EraParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 140);
        __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return match.era(dateString, { width: "abbreviated" }) || match.era(dateString, { width: "narrow" });
          case "GGGGG":
            return match.era(dateString, { width: "narrow" });
          case "GGGG":
          default:
            return match.era(dateString, { width: "wide" }) || match.era(dateString, { width: "abbreviated" }) || match.era(dateString, { width: "narrow" });
        }
      }
      set(date, flags, value) {
        flags.era = value;
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.EraParser = EraParser;
  }
});

// node_modules/date-fns/parse/_lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/date-fns/parse/_lib/constants.js"(exports) {
    "use strict";
    exports.timezonePatterns = exports.numericPatterns = void 0;
    var numericPatterns = exports.numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59
      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/
      // 0 to 9999, -0 to -9999
    };
    var timezonePatterns = exports.timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };
  }
});

// node_modules/date-fns/parse/_lib/utils.js
var require_utils = __commonJS({
  "node_modules/date-fns/parse/_lib/utils.js"(exports) {
    "use strict";
    exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
    exports.isLeapYearIndex = isLeapYearIndex;
    exports.mapValue = mapValue;
    exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
    exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
    exports.parseNDigits = parseNDigits;
    exports.parseNDigitsSigned = parseNDigitsSigned;
    exports.parseNumericPattern = parseNumericPattern;
    exports.parseTimezonePattern = parseTimezonePattern;
    var _index = require_constants();
    var _constants = require_constants2();
    function mapValue(parseFnResult, mapFn) {
      if (!parseFnResult) {
        return parseFnResult;
      }
      return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
      };
    }
    function parseNumericPattern(pattern, dateString) {
      const matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseTimezonePattern(pattern, dateString) {
      const matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      if (matchResult[0] === "Z") {
        return {
          value: 0,
          rest: dateString.slice(1)
        };
      }
      const sign = matchResult[1] === "+" ? 1 : -1;
      const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
      const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
      const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
      return {
        value: sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * _index.millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseAnyDigitsSigned(dateString) {
      return parseNumericPattern(
        _constants.numericPatterns.anyDigitsSigned,
        dateString
      );
    }
    function parseNDigits(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(
            _constants.numericPatterns.singleDigit,
            dateString
          );
        case 2:
          return parseNumericPattern(
            _constants.numericPatterns.twoDigits,
            dateString
          );
        case 3:
          return parseNumericPattern(
            _constants.numericPatterns.threeDigits,
            dateString
          );
        case 4:
          return parseNumericPattern(
            _constants.numericPatterns.fourDigits,
            dateString
          );
        default:
          return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
      }
    }
    function parseNDigitsSigned(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(
            _constants.numericPatterns.singleDigitSigned,
            dateString
          );
        case 2:
          return parseNumericPattern(
            _constants.numericPatterns.twoDigitsSigned,
            dateString
          );
        case 3:
          return parseNumericPattern(
            _constants.numericPatterns.threeDigitsSigned,
            dateString
          );
        case 4:
          return parseNumericPattern(
            _constants.numericPatterns.fourDigitsSigned,
            dateString
          );
        default:
          return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
      }
    }
    function dayPeriodEnumToHours(dayPeriod) {
      switch (dayPeriod) {
        case "morning":
          return 4;
        case "evening":
          return 17;
        case "pm":
        case "noon":
        case "afternoon":
          return 12;
        case "am":
        case "midnight":
        case "night":
        default:
          return 0;
      }
    }
    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
      const isCommonEra = currentYear > 0;
      const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
      let result;
      if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
      } else {
        const rangeEnd = absCurrentYear + 50;
        const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
        const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
      }
      return isCommonEra ? result : 1 - result;
    }
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/YearParser.js
var require_YearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/YearParser.js"(exports) {
    "use strict";
    exports.YearParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var YearParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 130);
        __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
      }
      parse(dateString, token, match) {
        const valueCallback = (year) => ({
          year,
          isTwoDigitYear: token === "yy"
        });
        switch (token) {
          case "y":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(4, dateString),
              valueCallback
            );
          case "yo":
            return (0, _utils.mapValue)(
              match.ordinalNumber(dateString, {
                unit: "year"
              }),
              valueCallback
            );
          default:
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token.length, dateString),
              valueCallback
            );
        }
      }
      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
      set(date, flags, value) {
        const currentYear = date.getFullYear();
        if (value.isTwoDigitYear) {
          const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
            value.year,
            currentYear
          );
          date.setFullYear(normalizedTwoDigitYear, 0, 1);
          date.setHours(0, 0, 0, 0);
          return date;
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.YearParser = YearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var require_LocalWeekYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js"(exports) {
    "use strict";
    exports.LocalWeekYearParser = void 0;
    var _index = require_getWeekYear();
    var _index2 = require_startOfWeek();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var LocalWeekYearParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 130);
        __publicField(this, "incompatibleTokens", [
          "y",
          "R",
          "u",
          "Q",
          "q",
          "M",
          "L",
          "I",
          "d",
          "D",
          "i",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        const valueCallback = (year) => ({
          year,
          isTwoDigitYear: token === "YY"
        });
        switch (token) {
          case "Y":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(4, dateString),
              valueCallback
            );
          case "Yo":
            return (0, _utils.mapValue)(
              match.ordinalNumber(dateString, {
                unit: "year"
              }),
              valueCallback
            );
          default:
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token.length, dateString),
              valueCallback
            );
        }
      }
      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
      set(date, flags, value, options) {
        const currentYear = (0, _index.getWeekYear)(date, options);
        if (value.isTwoDigitYear) {
          const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
            value.year,
            currentYear
          );
          date.setFullYear(
            normalizedTwoDigitYear,
            0,
            options.firstWeekContainsDate
          );
          date.setHours(0, 0, 0, 0);
          return (0, _index2.startOfWeek)(date, options);
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, options.firstWeekContainsDate);
        date.setHours(0, 0, 0, 0);
        return (0, _index2.startOfWeek)(date, options);
      }
    };
    exports.LocalWeekYearParser = LocalWeekYearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var require_ISOWeekYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js"(exports) {
    "use strict";
    exports.ISOWeekYearParser = void 0;
    var _index = require_startOfISOWeek();
    var _index2 = require_constructFrom();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOWeekYearParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 130);
        __publicField(this, "incompatibleTokens", [
          "G",
          "y",
          "Y",
          "u",
          "Q",
          "q",
          "M",
          "L",
          "w",
          "d",
          "D",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token) {
        if (token === "R") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
      }
      set(date, _flags, value) {
        const firstWeekOfYear = (0, _index2.constructFrom)(date, 0);
        firstWeekOfYear.setFullYear(value, 0, 4);
        firstWeekOfYear.setHours(0, 0, 0, 0);
        return (0, _index.startOfISOWeek)(firstWeekOfYear);
      }
    };
    exports.ISOWeekYearParser = ISOWeekYearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var require_ExtendedYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js"(exports) {
    "use strict";
    exports.ExtendedYearParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ExtendedYearParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 130);
        __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
      }
      parse(dateString, token) {
        if (token === "u") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
      }
      set(date, _flags, value) {
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.ExtendedYearParser = ExtendedYearParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var require_QuarterParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/QuarterParser.js"(exports) {
    "use strict";
    exports.QuarterParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var QuarterParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 120);
        __publicField(this, "incompatibleTokens", [
          "Y",
          "R",
          "q",
          "M",
          "L",
          "w",
          "I",
          "d",
          "D",
          "i",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "Q":
          case "QQ":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "Qo":
            return match.ordinalNumber(dateString, { unit: "quarter" });
          case "QQQ":
            return match.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQQ":
            return match.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return match.quarter(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 4;
      }
      set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.QuarterParser = QuarterParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var require_StandAloneQuarterParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js"(exports) {
    "use strict";
    exports.StandAloneQuarterParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var StandAloneQuarterParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 120);
        __publicField(this, "incompatibleTokens", [
          "Y",
          "R",
          "Q",
          "M",
          "L",
          "w",
          "I",
          "d",
          "D",
          "i",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "q":
          case "qq":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "qo":
            return match.ordinalNumber(dateString, { unit: "quarter" });
          case "qqq":
            return match.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqqq":
            return match.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return match.quarter(dateString, {
              width: "wide",
              context: "standalone"
            }) || match.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 4;
      }
      set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.StandAloneQuarterParser = StandAloneQuarterParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var require_MonthParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/MonthParser.js"(exports) {
    "use strict";
    exports.MonthParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var MonthParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "incompatibleTokens", [
          "Y",
          "R",
          "q",
          "Q",
          "L",
          "w",
          "I",
          "D",
          "i",
          "e",
          "c",
          "t",
          "T"
        ]);
        __publicField(this, "priority", 110);
      }
      parse(dateString, token, match) {
        const valueCallback = (value) => value - 1;
        switch (token) {
          case "M":
            return (0, _utils.mapValue)(
              (0, _utils.parseNumericPattern)(
                _constants.numericPatterns.month,
                dateString
              ),
              valueCallback
            );
          case "MM":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(2, dateString),
              valueCallback
            );
          case "Mo":
            return (0, _utils.mapValue)(
              match.ordinalNumber(dateString, {
                unit: "month"
              }),
              valueCallback
            );
          case "MMM":
            return match.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.month(dateString, { width: "narrow", context: "formatting" });
          case "MMMMM":
            return match.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return match.month(dateString, { width: "wide", context: "formatting" }) || match.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.month(dateString, { width: "narrow", context: "formatting" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 11;
      }
      set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.MonthParser = MonthParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var require_StandAloneMonthParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js"(exports) {
    "use strict";
    exports.StandAloneMonthParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var StandAloneMonthParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 110);
        __publicField(this, "incompatibleTokens", [
          "Y",
          "R",
          "q",
          "Q",
          "M",
          "w",
          "I",
          "D",
          "i",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        const valueCallback = (value) => value - 1;
        switch (token) {
          case "L":
            return (0, _utils.mapValue)(
              (0, _utils.parseNumericPattern)(
                _constants.numericPatterns.month,
                dateString
              ),
              valueCallback
            );
          case "LL":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(2, dateString),
              valueCallback
            );
          case "Lo":
            return (0, _utils.mapValue)(
              match.ordinalNumber(dateString, {
                unit: "month"
              }),
              valueCallback
            );
          case "LLL":
            return match.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.month(dateString, { width: "narrow", context: "standalone" });
          case "LLLLL":
            return match.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return match.month(dateString, { width: "wide", context: "standalone" }) || match.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.month(dateString, { width: "narrow", context: "standalone" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 11;
      }
      set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.StandAloneMonthParser = StandAloneMonthParser;
  }
});

// node_modules/date-fns/setWeek.js
var require_setWeek = __commonJS({
  "node_modules/date-fns/setWeek.js"(exports) {
    "use strict";
    exports.setWeek = setWeek;
    var _index = require_getWeek();
    var _index2 = require_toDate();
    function setWeek(date, week, options) {
      const _date = (0, _index2.toDate)(date);
      const diff = (0, _index.getWeek)(_date, options) - week;
      _date.setDate(_date.getDate() - diff * 7);
      return _date;
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var require_LocalWeekParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js"(exports) {
    "use strict";
    exports.LocalWeekParser = void 0;
    var _index = require_setWeek();
    var _index2 = require_startOfWeek();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var LocalWeekParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 100);
        __publicField(this, "incompatibleTokens", [
          "y",
          "R",
          "u",
          "q",
          "Q",
          "M",
          "L",
          "I",
          "d",
          "D",
          "i",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "w":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.week,
              dateString
            );
          case "wo":
            return match.ordinalNumber(dateString, { unit: "week" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 53;
      }
      set(date, _flags, value, options) {
        return (0, _index2.startOfWeek)(
          (0, _index.setWeek)(date, value, options),
          options
        );
      }
    };
    exports.LocalWeekParser = LocalWeekParser;
  }
});

// node_modules/date-fns/setISOWeek.js
var require_setISOWeek = __commonJS({
  "node_modules/date-fns/setISOWeek.js"(exports) {
    "use strict";
    exports.setISOWeek = setISOWeek;
    var _index = require_getISOWeek();
    var _index2 = require_toDate();
    function setISOWeek(date, week) {
      const _date = (0, _index2.toDate)(date);
      const diff = (0, _index.getISOWeek)(_date) - week;
      _date.setDate(_date.getDate() - diff * 7);
      return _date;
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var require_ISOWeekParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js"(exports) {
    "use strict";
    exports.ISOWeekParser = void 0;
    var _index = require_setISOWeek();
    var _index2 = require_startOfISOWeek();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOWeekParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 100);
        __publicField(this, "incompatibleTokens", [
          "y",
          "Y",
          "u",
          "q",
          "Q",
          "M",
          "L",
          "w",
          "d",
          "D",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "I":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.week,
              dateString
            );
          case "Io":
            return match.ordinalNumber(dateString, { unit: "week" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 53;
      }
      set(date, _flags, value) {
        return (0, _index2.startOfISOWeek)((0, _index.setISOWeek)(date, value));
      }
    };
    exports.ISOWeekParser = ISOWeekParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/DateParser.js
var require_DateParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DateParser.js"(exports) {
    "use strict";
    exports.DateParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [
      31,
      29,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ];
    var DateParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 90);
        __publicField(this, "subPriority", 1);
        __publicField(this, "incompatibleTokens", [
          "Y",
          "R",
          "q",
          "Q",
          "w",
          "I",
          "D",
          "i",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "d":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.date,
              dateString
            );
          case "do":
            return match.ordinalNumber(dateString, { unit: "date" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear = (0, _utils.isLeapYearIndex)(year);
        const month = date.getMonth();
        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      }
      set(date, _flags, value) {
        date.setDate(value);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.DateParser = DateParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var require_DayOfYearParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js"(exports) {
    "use strict";
    exports.DayOfYearParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var DayOfYearParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 90);
        __publicField(this, "subpriority", 1);
        __publicField(this, "incompatibleTokens", [
          "Y",
          "R",
          "q",
          "Q",
          "M",
          "L",
          "w",
          "I",
          "d",
          "E",
          "i",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "D":
          case "DD":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.dayOfYear,
              dateString
            );
          case "Do":
            return match.ordinalNumber(dateString, { unit: "date" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear = (0, _utils.isLeapYearIndex)(year);
        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }
      set(date, _flags, value) {
        date.setMonth(0, value);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.DayOfYearParser = DayOfYearParser;
  }
});

// node_modules/date-fns/setDay.js
var require_setDay = __commonJS({
  "node_modules/date-fns/setDay.js"(exports) {
    "use strict";
    exports.setDay = setDay;
    var _index = require_addDays();
    var _index2 = require_toDate();
    var _index3 = require_defaultOptions();
    function setDay(date, day, options) {
      var _a, _b, _c, _d;
      const defaultOptions = (0, _index3.getDefaultOptions)();
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
      const _date = (0, _index2.toDate)(date);
      const currentDay = _date.getDay();
      const remainder = day % 7;
      const dayIndex = (remainder + 7) % 7;
      const delta = 7 - weekStartsOn;
      const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
      return (0, _index.addDays)(_date, diff);
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/DayParser.js
var require_DayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DayParser.js"(exports) {
    "use strict";
    exports.DayParser = void 0;
    var _index = require_setDay();
    var _Parser = require_Parser();
    var DayParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 90);
        __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
          case "EEEEE":
            return match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
          case "EEEE":
          default:
            return match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 6;
      }
      set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.DayParser = DayParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var require_LocalDayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js"(exports) {
    "use strict";
    exports.LocalDayParser = void 0;
    var _index = require_setDay();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var LocalDayParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 90);
        __publicField(this, "incompatibleTokens", [
          "y",
          "R",
          "u",
          "q",
          "Q",
          "M",
          "L",
          "I",
          "d",
          "D",
          "E",
          "i",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match, options) {
        const valueCallback = (value) => {
          const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "e":
          case "ee":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token.length, dateString),
              valueCallback
            );
          case "eo":
            return (0, _utils.mapValue)(
              match.ordinalNumber(dateString, {
                unit: "day"
              }),
              valueCallback
            );
          case "eee":
            return match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
          case "eeeee":
            return match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
          case "eeee":
          default:
            return match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 6;
      }
      set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.LocalDayParser = LocalDayParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var require_StandAloneLocalDayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js"(exports) {
    "use strict";
    exports.StandAloneLocalDayParser = void 0;
    var _index = require_setDay();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var StandAloneLocalDayParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 90);
        __publicField(this, "incompatibleTokens", [
          "y",
          "R",
          "u",
          "q",
          "Q",
          "M",
          "L",
          "I",
          "d",
          "D",
          "E",
          "i",
          "e",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match, options) {
        const valueCallback = (value) => {
          const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "c":
          case "cc":
            return (0, _utils.mapValue)(
              (0, _utils.parseNDigits)(token.length, dateString),
              valueCallback
            );
          case "co":
            return (0, _utils.mapValue)(
              match.ordinalNumber(dateString, {
                unit: "day"
              }),
              valueCallback
            );
          case "ccc":
            return match.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
          case "ccccc":
            return match.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
          case "cccc":
          default:
            return match.day(dateString, { width: "wide", context: "standalone" }) || match.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 6;
      }
      set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.StandAloneLocalDayParser = StandAloneLocalDayParser;
  }
});

// node_modules/date-fns/getISODay.js
var require_getISODay = __commonJS({
  "node_modules/date-fns/getISODay.js"(exports) {
    "use strict";
    exports.getISODay = getISODay;
    var _index = require_toDate();
    function getISODay(date) {
      const _date = (0, _index.toDate)(date);
      let day = _date.getDay();
      if (day === 0) {
        day = 7;
      }
      return day;
    }
  }
});

// node_modules/date-fns/setISODay.js
var require_setISODay = __commonJS({
  "node_modules/date-fns/setISODay.js"(exports) {
    "use strict";
    exports.setISODay = setISODay;
    var _index = require_addDays();
    var _index2 = require_getISODay();
    var _index3 = require_toDate();
    function setISODay(date, day) {
      const _date = (0, _index3.toDate)(date);
      const currentDay = (0, _index2.getISODay)(_date);
      const diff = day - currentDay;
      return (0, _index.addDays)(_date, diff);
    }
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var require_ISODayParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISODayParser.js"(exports) {
    "use strict";
    exports.ISODayParser = void 0;
    var _index = require_setISODay();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISODayParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 90);
        __publicField(this, "incompatibleTokens", [
          "y",
          "Y",
          "u",
          "q",
          "Q",
          "M",
          "L",
          "w",
          "d",
          "D",
          "E",
          "e",
          "c",
          "t",
          "T"
        ]);
      }
      parse(dateString, token, match) {
        const valueCallback = (value) => {
          if (value === 0) {
            return 7;
          }
          return value;
        };
        switch (token) {
          case "i":
          case "ii":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "io":
            return match.ordinalNumber(dateString, { unit: "day" });
          case "iii":
            return (0, _utils.mapValue)(
              match.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
          case "iiiii":
            return (0, _utils.mapValue)(
              match.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
          case "iiiiii":
            return (0, _utils.mapValue)(
              match.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
          case "iiii":
          default:
            return (0, _utils.mapValue)(
              match.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match.day(dateString, {
                width: "narrow",
                context: "formatting"
              }),
              valueCallback
            );
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 7;
      }
      set(date, _flags, value) {
        date = (0, _index.setISODay)(date, value);
        date.setHours(0, 0, 0, 0);
        return date;
      }
    };
    exports.ISODayParser = ISODayParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var require_AMPMParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/AMPMParser.js"(exports) {
    "use strict";
    exports.AMPMParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var AMPMParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 80);
        __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaaa":
            return match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
      }
    };
    exports.AMPMParser = AMPMParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var require_AMPMMidnightParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js"(exports) {
    "use strict";
    exports.AMPMMidnightParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var AMPMMidnightParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 80);
        __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "b":
          case "bb":
          case "bbb":
            return match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbbb":
            return match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
      }
    };
    exports.AMPMMidnightParser = AMPMMidnightParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var require_DayPeriodParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js"(exports) {
    "use strict";
    exports.DayPeriodParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var DayPeriodParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 80);
        __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBBB":
            return match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
      set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
      }
    };
    exports.DayPeriodParser = DayPeriodParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var require_Hour1to12Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js"(exports) {
    "use strict";
    exports.Hour1to12Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour1to12Parser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 70);
        __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "h":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour12h,
              dateString
            );
          case "ho":
            return match.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 12;
      }
      set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) {
          date.setHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setHours(0, 0, 0, 0);
        } else {
          date.setHours(value, 0, 0, 0);
        }
        return date;
      }
    };
    exports.Hour1to12Parser = Hour1to12Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var require_Hour0to23Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js"(exports) {
    "use strict";
    exports.Hour0to23Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour0to23Parser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 70);
        __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "H":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour23h,
              dateString
            );
          case "Ho":
            return match.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 23;
      }
      set(date, _flags, value) {
        date.setHours(value, 0, 0, 0);
        return date;
      }
    };
    exports.Hour0to23Parser = Hour0to23Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var require_Hour0To11Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js"(exports) {
    "use strict";
    exports.Hour0To11Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour0To11Parser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 70);
        __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "K":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour11h,
              dateString
            );
          case "Ko":
            return match.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 11;
      }
      set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) {
          date.setHours(value + 12, 0, 0, 0);
        } else {
          date.setHours(value, 0, 0, 0);
        }
        return date;
      }
    };
    exports.Hour0To11Parser = Hour0To11Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var require_Hour1To24Parser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js"(exports) {
    "use strict";
    exports.Hour1To24Parser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var Hour1To24Parser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 70);
        __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "k":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.hour24h,
              dateString
            );
          case "ko":
            return match.ordinalNumber(dateString, { unit: "hour" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 1 && value <= 24;
      }
      set(date, _flags, value) {
        const hours = value <= 24 ? value % 24 : value;
        date.setHours(hours, 0, 0, 0);
        return date;
      }
    };
    exports.Hour1To24Parser = Hour1To24Parser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var require_MinuteParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/MinuteParser.js"(exports) {
    "use strict";
    exports.MinuteParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var MinuteParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 60);
        __publicField(this, "incompatibleTokens", ["t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "m":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.minute,
              dateString
            );
          case "mo":
            return match.ordinalNumber(dateString, { unit: "minute" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 59;
      }
      set(date, _flags, value) {
        date.setMinutes(value, 0, 0);
        return date;
      }
    };
    exports.MinuteParser = MinuteParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var require_SecondParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/SecondParser.js"(exports) {
    "use strict";
    exports.SecondParser = void 0;
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var SecondParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 50);
        __publicField(this, "incompatibleTokens", ["t", "T"]);
      }
      parse(dateString, token, match) {
        switch (token) {
          case "s":
            return (0, _utils.parseNumericPattern)(
              _constants.numericPatterns.second,
              dateString
            );
          case "so":
            return match.ordinalNumber(dateString, { unit: "second" });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
      validate(_date, value) {
        return value >= 0 && value <= 59;
      }
      set(date, _flags, value) {
        date.setSeconds(value, 0);
        return date;
      }
    };
    exports.SecondParser = SecondParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var require_FractionOfSecondParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js"(exports) {
    "use strict";
    exports.FractionOfSecondParser = void 0;
    var _Parser = require_Parser();
    var _utils = require_utils();
    var FractionOfSecondParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 30);
        __publicField(this, "incompatibleTokens", ["t", "T"]);
      }
      parse(dateString, token) {
        const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token.length, dateString),
          valueCallback
        );
      }
      set(date, _flags, value) {
        date.setMilliseconds(value);
        return date;
      }
    };
    exports.FractionOfSecondParser = FractionOfSecondParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var require_ISOTimezoneWithZParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js"(exports) {
    "use strict";
    exports.ISOTimezoneWithZParser = void 0;
    var _index = require_constructFrom();
    var _index2 = require_getTimezoneOffsetInMilliseconds();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOTimezoneWithZParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 10);
        __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
      }
      parse(dateString, token) {
        switch (token) {
          case "X":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalMinutes,
              dateString
            );
          case "XX":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basic,
              dateString
            );
          case "XXXX":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalSeconds,
              dateString
            );
          case "XXXXX":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extendedOptionalSeconds,
              dateString
            );
          case "XXX":
          default:
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extended,
              dateString
            );
        }
      }
      set(date, flags, value) {
        if (flags.timestampIsSet)
          return date;
        return (0, _index.constructFrom)(
          date,
          date.getTime() - (0, _index2.getTimezoneOffsetInMilliseconds)(date) - value
        );
      }
    };
    exports.ISOTimezoneWithZParser = ISOTimezoneWithZParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var require_ISOTimezoneParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js"(exports) {
    "use strict";
    exports.ISOTimezoneParser = void 0;
    var _index = require_constructFrom();
    var _index2 = require_getTimezoneOffsetInMilliseconds();
    var _constants = require_constants2();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var ISOTimezoneParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 10);
        __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
      }
      parse(dateString, token) {
        switch (token) {
          case "x":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalMinutes,
              dateString
            );
          case "xx":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basic,
              dateString
            );
          case "xxxx":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.basicOptionalSeconds,
              dateString
            );
          case "xxxxx":
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extendedOptionalSeconds,
              dateString
            );
          case "xxx":
          default:
            return (0, _utils.parseTimezonePattern)(
              _constants.timezonePatterns.extended,
              dateString
            );
        }
      }
      set(date, flags, value) {
        if (flags.timestampIsSet)
          return date;
        return (0, _index.constructFrom)(
          date,
          date.getTime() - (0, _index2.getTimezoneOffsetInMilliseconds)(date) - value
        );
      }
    };
    exports.ISOTimezoneParser = ISOTimezoneParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var require_TimestampSecondsParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js"(exports) {
    "use strict";
    exports.TimestampSecondsParser = void 0;
    var _index = require_constructFrom();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var TimestampSecondsParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 40);
        __publicField(this, "incompatibleTokens", "*");
      }
      parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
      set(date, _flags, value) {
        return [
          (0, _index.constructFrom)(date, value * 1e3),
          { timestampIsSet: true }
        ];
      }
    };
    exports.TimestampSecondsParser = TimestampSecondsParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var require_TimestampMillisecondsParser = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js"(exports) {
    "use strict";
    exports.TimestampMillisecondsParser = void 0;
    var _index = require_constructFrom();
    var _Parser = require_Parser();
    var _utils = require_utils();
    var TimestampMillisecondsParser = class extends _Parser.Parser {
      constructor() {
        super(...arguments);
        __publicField(this, "priority", 20);
        __publicField(this, "incompatibleTokens", "*");
      }
      parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
      set(date, _flags, value) {
        return [(0, _index.constructFrom)(date, value), { timestampIsSet: true }];
      }
    };
    exports.TimestampMillisecondsParser = TimestampMillisecondsParser;
  }
});

// node_modules/date-fns/parse/_lib/parsers.js
var require_parsers = __commonJS({
  "node_modules/date-fns/parse/_lib/parsers.js"(exports) {
    "use strict";
    exports.parsers = void 0;
    var _EraParser = require_EraParser();
    var _YearParser = require_YearParser();
    var _LocalWeekYearParser = require_LocalWeekYearParser();
    var _ISOWeekYearParser = require_ISOWeekYearParser();
    var _ExtendedYearParser = require_ExtendedYearParser();
    var _QuarterParser = require_QuarterParser();
    var _StandAloneQuarterParser = require_StandAloneQuarterParser();
    var _MonthParser = require_MonthParser();
    var _StandAloneMonthParser = require_StandAloneMonthParser();
    var _LocalWeekParser = require_LocalWeekParser();
    var _ISOWeekParser = require_ISOWeekParser();
    var _DateParser = require_DateParser();
    var _DayOfYearParser = require_DayOfYearParser();
    var _DayParser = require_DayParser();
    var _LocalDayParser = require_LocalDayParser();
    var _StandAloneLocalDayParser = require_StandAloneLocalDayParser();
    var _ISODayParser = require_ISODayParser();
    var _AMPMParser = require_AMPMParser();
    var _AMPMMidnightParser = require_AMPMMidnightParser();
    var _DayPeriodParser = require_DayPeriodParser();
    var _Hour1to12Parser = require_Hour1to12Parser();
    var _Hour0to23Parser = require_Hour0to23Parser();
    var _Hour0To11Parser = require_Hour0To11Parser();
    var _Hour1To24Parser = require_Hour1To24Parser();
    var _MinuteParser = require_MinuteParser();
    var _SecondParser = require_SecondParser();
    var _FractionOfSecondParser = require_FractionOfSecondParser();
    var _ISOTimezoneWithZParser = require_ISOTimezoneWithZParser();
    var _ISOTimezoneParser = require_ISOTimezoneParser();
    var _TimestampSecondsParser = require_TimestampSecondsParser();
    var _TimestampMillisecondsParser = require_TimestampMillisecondsParser();
    var parsers = exports.parsers = {
      G: new _EraParser.EraParser(),
      y: new _YearParser.YearParser(),
      Y: new _LocalWeekYearParser.LocalWeekYearParser(),
      R: new _ISOWeekYearParser.ISOWeekYearParser(),
      u: new _ExtendedYearParser.ExtendedYearParser(),
      Q: new _QuarterParser.QuarterParser(),
      q: new _StandAloneQuarterParser.StandAloneQuarterParser(),
      M: new _MonthParser.MonthParser(),
      L: new _StandAloneMonthParser.StandAloneMonthParser(),
      w: new _LocalWeekParser.LocalWeekParser(),
      I: new _ISOWeekParser.ISOWeekParser(),
      d: new _DateParser.DateParser(),
      D: new _DayOfYearParser.DayOfYearParser(),
      E: new _DayParser.DayParser(),
      e: new _LocalDayParser.LocalDayParser(),
      c: new _StandAloneLocalDayParser.StandAloneLocalDayParser(),
      i: new _ISODayParser.ISODayParser(),
      a: new _AMPMParser.AMPMParser(),
      b: new _AMPMMidnightParser.AMPMMidnightParser(),
      B: new _DayPeriodParser.DayPeriodParser(),
      h: new _Hour1to12Parser.Hour1to12Parser(),
      H: new _Hour0to23Parser.Hour0to23Parser(),
      K: new _Hour0To11Parser.Hour0To11Parser(),
      k: new _Hour1To24Parser.Hour1To24Parser(),
      m: new _MinuteParser.MinuteParser(),
      s: new _SecondParser.SecondParser(),
      S: new _FractionOfSecondParser.FractionOfSecondParser(),
      X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser(),
      x: new _ISOTimezoneParser.ISOTimezoneParser(),
      t: new _TimestampSecondsParser.TimestampSecondsParser(),
      T: new _TimestampMillisecondsParser.TimestampMillisecondsParser()
    };
  }
});

// node_modules/date-fns/parse.js
var require_parse = __commonJS({
  "node_modules/date-fns/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "longFormatters", {
      enumerable: true,
      get: function() {
        return _index5.longFormatters;
      }
    });
    exports.parse = parse;
    Object.defineProperty(exports, "parsers", {
      enumerable: true,
      get: function() {
        return _index7.parsers;
      }
    });
    var _index = require_constructFrom();
    var _index2 = require_getDefaultOptions();
    var _index3 = require_defaultLocale();
    var _index4 = require_toDate();
    var _index5 = require_longFormatters();
    var _index6 = require_protectedTokens();
    var _index7 = require_parsers();
    var _Setter = require_Setter();
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var notWhitespaceRegExp = /\S/;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function parse(dateStr, formatStr, referenceDate, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const defaultOptions = (0, _index2.getDefaultOptions)();
      const locale = (options == null ? void 0 : options.locale) ?? defaultOptions.locale ?? _index3.defaultLocale;
      const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_h = (_g = defaultOptions.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
      if (formatStr === "") {
        if (dateStr === "") {
          return (0, _index4.toDate)(referenceDate);
        } else {
          return (0, _index.constructFrom)(referenceDate, NaN);
        }
      }
      const subFnOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
      };
      const setters = [new _Setter.DateToSystemTimezoneSetter()];
      const tokens = formatStr.match(longFormattingTokensRegExp).map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter in _index5.longFormatters) {
          const longFormatter = _index5.longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp);
      const usedTokens = [];
      for (let token of tokens) {
        if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && (0, _index6.isProtectedWeekYearToken)(token)) {
          (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
        }
        if (!(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && (0, _index6.isProtectedDayOfYearToken)(token)) {
          (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
        }
        const firstCharacter = token[0];
        const parser = _index7.parsers[firstCharacter];
        if (parser) {
          const { incompatibleTokens } = parser;
          if (Array.isArray(incompatibleTokens)) {
            const incompatibleToken = usedTokens.find(
              (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
            );
            if (incompatibleToken) {
              throw new RangeError(
                `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
              );
            }
          } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
            throw new RangeError(
              `The format string mustn't contain \`${token}\` and any other token at the same time`
            );
          }
          usedTokens.push({ token: firstCharacter, fullToken: token });
          const parseResult = parser.run(
            dateStr,
            token,
            locale.match,
            subFnOptions
          );
          if (!parseResult) {
            return (0, _index.constructFrom)(referenceDate, NaN);
          }
          setters.push(parseResult.setter);
          dateStr = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError(
              "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
            );
          }
          if (token === "''") {
            token = "'";
          } else if (firstCharacter === "'") {
            token = cleanEscapedString(token);
          }
          if (dateStr.indexOf(token) === 0) {
            dateStr = dateStr.slice(token.length);
          } else {
            return (0, _index.constructFrom)(referenceDate, NaN);
          }
        }
      }
      if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }
      const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index2, array) => array.indexOf(priority) === index2).map(
        (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
      ).map((setterArray) => setterArray[0]);
      let date = (0, _index4.toDate)(referenceDate);
      if (isNaN(date.getTime())) {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }
      const flags = {};
      for (const setter of uniquePrioritySetters) {
        if (!setter.validate(date, subFnOptions)) {
          return (0, _index.constructFrom)(referenceDate, NaN);
        }
        const result = setter.set(date, flags, subFnOptions);
        if (Array.isArray(result)) {
          date = result[0];
          Object.assign(flags, result[1]);
        } else {
          date = result;
        }
      }
      return (0, _index.constructFrom)(referenceDate, date);
    }
    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }
  }
});

// node_modules/date-fns/parseISO.js
var require_parseISO = __commonJS({
  "node_modules/date-fns/parseISO.js"(exports) {
    "use strict";
    exports.parseISO = parseISO;
    var _index = require_constants();
    function parseISO(argument, options) {
      const additionalDigits = (options == null ? void 0 : options.additionalDigits) ?? 2;
      const dateStrings = splitDateString(argument);
      let date;
      if (dateStrings.date) {
        const parseYearResult = parseYear(dateStrings.date, additionalDigits);
        date = parseDate(parseYearResult.restDateString, parseYearResult.year);
      }
      if (!date || isNaN(date.getTime())) {
        return /* @__PURE__ */ new Date(NaN);
      }
      const timestamp = date.getTime();
      let time = 0;
      let offset2;
      if (dateStrings.time) {
        time = parseTime(dateStrings.time);
        if (isNaN(time)) {
          return /* @__PURE__ */ new Date(NaN);
        }
      }
      if (dateStrings.timezone) {
        offset2 = parseTimezone(dateStrings.timezone);
        if (isNaN(offset2)) {
          return /* @__PURE__ */ new Date(NaN);
        }
      } else {
        const dirtyDate = new Date(timestamp + time);
        const result = /* @__PURE__ */ new Date(0);
        result.setFullYear(
          dirtyDate.getUTCFullYear(),
          dirtyDate.getUTCMonth(),
          dirtyDate.getUTCDate()
        );
        result.setHours(
          dirtyDate.getUTCHours(),
          dirtyDate.getUTCMinutes(),
          dirtyDate.getUTCSeconds(),
          dirtyDate.getUTCMilliseconds()
        );
        return result;
      }
      return new Date(timestamp + time + offset2);
    }
    var patterns = {
      dateTimeDelimiter: /[T ]/,
      timeZoneDelimiter: /[Z ]/i,
      timezone: /([Z+-].*)$/
    };
    var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
    var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
    var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
    function splitDateString(dateString) {
      const dateStrings = {};
      const array = dateString.split(patterns.dateTimeDelimiter);
      let timeString;
      if (array.length > 2) {
        return dateStrings;
      }
      if (/:/.test(array[0])) {
        timeString = array[0];
      } else {
        dateStrings.date = array[0];
        timeString = array[1];
        if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
          dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
          timeString = dateString.substr(
            dateStrings.date.length,
            dateString.length
          );
        }
      }
      if (timeString) {
        const token = patterns.timezone.exec(timeString);
        if (token) {
          dateStrings.time = timeString.replace(token[1], "");
          dateStrings.timezone = token[1];
        } else {
          dateStrings.time = timeString;
        }
      }
      return dateStrings;
    }
    function parseYear(dateString, additionalDigits) {
      const regex = new RegExp(
        "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
      );
      const captures = dateString.match(regex);
      if (!captures)
        return { year: NaN, restDateString: "" };
      const year = captures[1] ? parseInt(captures[1]) : null;
      const century = captures[2] ? parseInt(captures[2]) : null;
      return {
        year: century === null ? year : century * 100,
        restDateString: dateString.slice((captures[1] || captures[2]).length)
      };
    }
    function parseDate(dateString, year) {
      if (year === null)
        return /* @__PURE__ */ new Date(NaN);
      const captures = dateString.match(dateRegex);
      if (!captures)
        return /* @__PURE__ */ new Date(NaN);
      const isWeekDate = !!captures[4];
      const dayOfYear = parseDateUnit(captures[1]);
      const month = parseDateUnit(captures[2]) - 1;
      const day = parseDateUnit(captures[3]);
      const week = parseDateUnit(captures[4]);
      const dayOfWeek = parseDateUnit(captures[5]) - 1;
      if (isWeekDate) {
        if (!validateWeekDate(year, week, dayOfWeek)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        return dayOfISOWeekYear(year, week, dayOfWeek);
      } else {
        const date = /* @__PURE__ */ new Date(0);
        if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
        return date;
      }
    }
    function parseDateUnit(value) {
      return value ? parseInt(value) : 1;
    }
    function parseTime(timeString) {
      const captures = timeString.match(timeRegex);
      if (!captures)
        return NaN;
      const hours = parseTimeUnit(captures[1]);
      const minutes = parseTimeUnit(captures[2]);
      const seconds = parseTimeUnit(captures[3]);
      if (!validateTime(hours, minutes, seconds)) {
        return NaN;
      }
      return hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * 1e3;
    }
    function parseTimeUnit(value) {
      return value && parseFloat(value.replace(",", ".")) || 0;
    }
    function parseTimezone(timezoneString) {
      if (timezoneString === "Z")
        return 0;
      const captures = timezoneString.match(timezoneRegex);
      if (!captures)
        return 0;
      const sign = captures[1] === "+" ? -1 : 1;
      const hours = parseInt(captures[2]);
      const minutes = captures[3] && parseInt(captures[3]) || 0;
      if (!validateTimezone(hours, minutes)) {
        return NaN;
      }
      return sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute);
    }
    function dayOfISOWeekYear(isoWeekYear, week, day) {
      const date = /* @__PURE__ */ new Date(0);
      date.setUTCFullYear(isoWeekYear, 0, 4);
      const fourthOfJanuaryDay = date.getUTCDay() || 7;
      const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }
    var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }
    function validateDate(year, month, date) {
      return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
    }
    function validateDayOfYearDate(year, dayOfYear) {
      return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
    }
    function validateWeekDate(_year, week, day) {
      return week >= 1 && week <= 53 && day >= 0 && day <= 6;
    }
    function validateTime(hours, minutes, seconds) {
      if (hours === 24) {
        return minutes === 0 && seconds === 0;
      }
      return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
    }
    function validateTimezone(_hours, minutes) {
      return minutes >= 0 && minutes <= 59;
    }
  }
});

// node_modules/date-fns/getDaysInMonth.js
var require_getDaysInMonth = __commonJS({
  "node_modules/date-fns/getDaysInMonth.js"(exports) {
    "use strict";
    exports.getDaysInMonth = getDaysInMonth;
    var _index = require_toDate();
    var _index2 = require_constructFrom();
    function getDaysInMonth(date) {
      const _date = (0, _index.toDate)(date);
      const year = _date.getFullYear();
      const monthIndex = _date.getMonth();
      const lastDayOfMonth = (0, _index2.constructFrom)(date, 0);
      lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
      lastDayOfMonth.setHours(0, 0, 0, 0);
      return lastDayOfMonth.getDate();
    }
  }
});

// node_modules/date-fns/setMonth.js
var require_setMonth = __commonJS({
  "node_modules/date-fns/setMonth.js"(exports) {
    "use strict";
    exports.setMonth = setMonth;
    var _index = require_constructFrom();
    var _index2 = require_getDaysInMonth();
    var _index3 = require_toDate();
    function setMonth(date, month) {
      const _date = (0, _index3.toDate)(date);
      const year = _date.getFullYear();
      const day = _date.getDate();
      const dateWithDesiredMonth = (0, _index.constructFrom)(date, 0);
      dateWithDesiredMonth.setFullYear(year, month, 15);
      dateWithDesiredMonth.setHours(0, 0, 0, 0);
      const daysInMonth = (0, _index2.getDaysInMonth)(dateWithDesiredMonth);
      _date.setMonth(month, Math.min(day, daysInMonth));
      return _date;
    }
  }
});

// node_modules/date-fns/set.js
var require_set = __commonJS({
  "node_modules/date-fns/set.js"(exports) {
    "use strict";
    exports.set = set;
    var _index = require_constructFrom();
    var _index2 = require_setMonth();
    var _index3 = require_toDate();
    function set(date, values) {
      let _date = (0, _index3.toDate)(date);
      if (isNaN(+_date)) {
        return (0, _index.constructFrom)(date, NaN);
      }
      if (values.year != null) {
        _date.setFullYear(values.year);
      }
      if (values.month != null) {
        _date = (0, _index2.setMonth)(_date, values.month);
      }
      if (values.date != null) {
        _date.setDate(values.date);
      }
      if (values.hours != null) {
        _date.setHours(values.hours);
      }
      if (values.minutes != null) {
        _date.setMinutes(values.minutes);
      }
      if (values.seconds != null) {
        _date.setSeconds(values.seconds);
      }
      if (values.milliseconds != null) {
        _date.setMilliseconds(values.milliseconds);
      }
      return _date;
    }
  }
});

// node_modules/date-fns/setHours.js
var require_setHours = __commonJS({
  "node_modules/date-fns/setHours.js"(exports) {
    "use strict";
    exports.setHours = setHours;
    var _index = require_toDate();
    function setHours(date, hours) {
      const _date = (0, _index.toDate)(date);
      _date.setHours(hours);
      return _date;
    }
  }
});

// node_modules/date-fns/setMinutes.js
var require_setMinutes = __commonJS({
  "node_modules/date-fns/setMinutes.js"(exports) {
    "use strict";
    exports.setMinutes = setMinutes;
    var _index = require_toDate();
    function setMinutes(date, minutes) {
      const _date = (0, _index.toDate)(date);
      _date.setMinutes(minutes);
      return _date;
    }
  }
});

// node_modules/date-fns/setQuarter.js
var require_setQuarter = __commonJS({
  "node_modules/date-fns/setQuarter.js"(exports) {
    "use strict";
    exports.setQuarter = setQuarter;
    var _index = require_setMonth();
    var _index2 = require_toDate();
    function setQuarter(date, quarter) {
      const _date = (0, _index2.toDate)(date);
      const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;
      const diff = quarter - oldQuarter;
      return (0, _index.setMonth)(_date, _date.getMonth() + diff * 3);
    }
  }
});

// node_modules/date-fns/setSeconds.js
var require_setSeconds = __commonJS({
  "node_modules/date-fns/setSeconds.js"(exports) {
    "use strict";
    exports.setSeconds = setSeconds;
    var _index = require_toDate();
    function setSeconds(date, seconds) {
      const _date = (0, _index.toDate)(date);
      _date.setSeconds(seconds);
      return _date;
    }
  }
});

// node_modules/date-fns/setYear.js
var require_setYear = __commonJS({
  "node_modules/date-fns/setYear.js"(exports) {
    "use strict";
    exports.setYear = setYear;
    var _index = require_constructFrom();
    var _index2 = require_toDate();
    function setYear(date, year) {
      const _date = (0, _index2.toDate)(date);
      if (isNaN(+_date)) {
        return (0, _index.constructFrom)(date, NaN);
      }
      _date.setFullYear(year);
      return _date;
    }
  }
});

// node_modules/date-fns/startOfMonth.js
var require_startOfMonth = __commonJS({
  "node_modules/date-fns/startOfMonth.js"(exports) {
    "use strict";
    exports.startOfMonth = startOfMonth;
    var _index = require_toDate();
    function startOfMonth(date) {
      const _date = (0, _index.toDate)(date);
      _date.setDate(1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
  }
});

// node_modules/date-fns/subDays.js
var require_subDays = __commonJS({
  "node_modules/date-fns/subDays.js"(exports) {
    "use strict";
    exports.subDays = subDays;
    var _index = require_addDays();
    function subDays(date, amount) {
      return (0, _index.addDays)(date, -amount);
    }
  }
});

// node_modules/date-fns/subMonths.js
var require_subMonths = __commonJS({
  "node_modules/date-fns/subMonths.js"(exports) {
    "use strict";
    exports.subMonths = subMonths;
    var _index = require_addMonths();
    function subMonths(date, amount) {
      return (0, _index.addMonths)(date, -amount);
    }
  }
});

// node_modules/date-fns/subQuarters.js
var require_subQuarters = __commonJS({
  "node_modules/date-fns/subQuarters.js"(exports) {
    "use strict";
    exports.subQuarters = subQuarters;
    var _index = require_addQuarters();
    function subQuarters(date, amount) {
      return (0, _index.addQuarters)(date, -amount);
    }
  }
});

// node_modules/date-fns/subWeeks.js
var require_subWeeks = __commonJS({
  "node_modules/date-fns/subWeeks.js"(exports) {
    "use strict";
    exports.subWeeks = subWeeks;
    var _index = require_addWeeks();
    function subWeeks(date, amount) {
      return (0, _index.addWeeks)(date, -amount);
    }
  }
});

// node_modules/date-fns/subYears.js
var require_subYears = __commonJS({
  "node_modules/date-fns/subYears.js"(exports) {
    "use strict";
    exports.subYears = subYears;
    var _index = require_addYears();
    function subYears(date, amount) {
      return (0, _index.addYears)(date, -amount);
    }
  }
});

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
var floating_ui_react_esm_exports = {};
__export(floating_ui_react_esm_exports, {
  Composite: () => Composite,
  CompositeItem: () => CompositeItem,
  FloatingArrow: () => FloatingArrow,
  FloatingDelayGroup: () => FloatingDelayGroup,
  FloatingFocusManager: () => FloatingFocusManager,
  FloatingList: () => FloatingList,
  FloatingNode: () => FloatingNode,
  FloatingOverlay: () => FloatingOverlay,
  FloatingPortal: () => FloatingPortal,
  FloatingTree: () => FloatingTree,
  arrow: () => arrow,
  autoPlacement: () => autoPlacement,
  autoUpdate: () => autoUpdate,
  computePosition: () => computePosition,
  detectOverflow: () => detectOverflow,
  flip: () => flip,
  getOverflowAncestors: () => getOverflowAncestors,
  hide: () => hide,
  inline: () => inline,
  inner: () => inner,
  limitShift: () => limitShift,
  offset: () => offset,
  platform: () => platform,
  safePolygon: () => safePolygon,
  shift: () => shift,
  size: () => size,
  useClick: () => useClick,
  useClientPoint: () => useClientPoint,
  useDelayGroup: () => useDelayGroup,
  useDelayGroupContext: () => useDelayGroupContext,
  useDismiss: () => useDismiss,
  useFloating: () => useFloating2,
  useFloatingNodeId: () => useFloatingNodeId,
  useFloatingParentNodeId: () => useFloatingParentNodeId,
  useFloatingPortalNode: () => useFloatingPortalNode,
  useFloatingRootContext: () => useFloatingRootContext,
  useFloatingTree: () => useFloatingTree,
  useFocus: () => useFocus,
  useHover: () => useHover,
  useId: () => useId,
  useInnerOffset: () => useInnerOffset,
  useInteractions: () => useInteractions,
  useListItem: () => useListItem,
  useListNavigation: () => useListNavigation,
  useMergeRefs: () => useMergeRefs,
  useRole: () => useRole,
  useTransitionStatus: () => useTransitionStatus,
  useTransitionStyles: () => useTransitionStyles,
  useTypeahead: () => useTypeahead
});
function useMergeRefs(refs) {
  return React.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function isDifferentRow(index2, cols, prevRow) {
  return Math.floor(index2 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index2) {
  return index2 < 0 || index2 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index2 = startingIndex;
  do {
    index2 += decrement ? -amount : amount;
  } while (index2 >= 0 && index2 <= list.length - 1 && isDisabled(list, index2, disabledIndices));
  return index2;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset2 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset2 : offset2 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === ARROW_RIGHT) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === ARROW_LEFT) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index2) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index2 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index2;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index2, sizes, cellMap, cols, corner) {
  if (index2 === -1)
    return -1;
  const firstCellIndex = cellMap.indexOf(index2);
  const sizeItem = sizes[index2];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index2);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index2, cellIndex) => indices.includes(index2) ? [cellIndex] : []);
}
function isDisabled(list, index2, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index2);
  }
  const element = list[index2];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function sortByDocumentPosition(a, b) {
  const position = a.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [map, setMap] = React.useState(() => /* @__PURE__ */ new Map());
  const register = React.useCallback((node) => {
    setMap((prevMap) => new Map(prevMap).set(node, null));
  }, []);
  const unregister = React.useCallback((node) => {
    setMap((prevMap) => {
      const map2 = new Map(prevMap);
      map2.delete(node);
      return map2;
    });
  }, []);
  index(() => {
    const newMap = new Map(map);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node, index2) => {
      newMap.set(node, index2);
    });
    if (!areMapsEqual(map, newMap)) {
      setMap(newMap);
    }
  }, [map]);
  return React.createElement(FloatingListContext.Provider, {
    value: React.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef])
  }, children);
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = React.useContext(FloatingListContext);
  const [index$1, setIndex] = React.useState(null);
  const componentRef = React.useRef(null);
  const ref = React.useCallback((node) => {
    componentRef.current = node;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label]);
  index(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index(() => {
    const index2 = componentRef.current ? map.get(componentRef.current) : null;
    if (index2 != null) {
      setIndex(index2);
    }
  }, [map]);
  return React.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React.cloneElement(render, computedProps);
  }
  return React.createElement("div", computedProps);
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function useFloatingId() {
  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
    }
  };
}
function useFloatingNodeId(customParentId) {
  const id = useId();
  const tree = useFloatingTree();
  const reactParentId = useFloatingParentNodeId();
  const parentId = customParentId || reactParentId;
  index(() => {
    const node = {
      id,
      parentId
    };
    tree == null || tree.addNode(node);
    return () => {
      tree == null || tree.removeNode(node);
    };
  }, [tree, id, parentId]);
  return id;
}
function FloatingNode(props) {
  const {
    children,
    id
  } = props;
  const parentId = useFloatingParentNodeId();
  return React.createElement(FloatingNodeContext.Provider, {
    value: React.useMemo(() => ({
      id,
      parentId
    }), [id, parentId])
  }, children);
}
function FloatingTree(props) {
  const {
    children
  } = props;
  const nodesRef = React.useRef([]);
  const addNode = React.useCallback((node) => {
    nodesRef.current = [...nodesRef.current, node];
  }, []);
  const removeNode = React.useCallback((node) => {
    nodesRef.current = nodesRef.current.filter((n) => n !== node);
  }, []);
  const events = React.useState(() => createPubSub())[0];
  return React.createElement(FloatingTreeContext.Provider, {
    value: React.useMemo(() => ({
      nodesRef,
      addNode,
      removeNode,
      events
    }), [addNode, removeNode, events])
  }, children);
}
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef(value) {
  const ref = (0, import_react.useRef)(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const openRef = useLatestRef(open);
  const pointerTypeRef = React.useRef();
  const timeoutRef = React.useRef(-1);
  const handlerRef = React.useRef();
  const restTimeoutRef = React.useRef(-1);
  const blockMouseMoveRef = React.useRef(true);
  const performedPointerEventsMutationRef = React.useRef(false);
  const unbindMouseMoveRef = React.useRef(() => {
  });
  const isHoverOpen = React.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeout(timeoutRef.current);
        clearTimeout(restTimeoutRef.current);
        blockMouseMoveRef.current = true;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]);
  React.useEffect(() => {
    if (!enabled)
      return;
    if (!handleCloseRef.current)
      return;
    if (!open)
      return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(elements.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  React.useEffect(() => {
    if (!enabled)
      return;
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else {
        onOpenChange(true, event, "hover");
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent())
        return;
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            closeWithDelay(event, true, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent())
        return;
      if (!dataRef.current.floatingContext)
        return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          closeWithDelay(event);
        }
      })(event);
    }
    if (isElement(elements.domReference)) {
      var _elements$floating;
      const ref = elements.domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      (_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        var _elements$floating2;
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave);
        move && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [elements, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef]);
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled)
      return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || restMs === 0) {
          return;
        }
        clearTimeout(restTimeoutRef.current);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMs]);
  const floating = React.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(timeoutRef.current);
    },
    onMouseLeave(event) {
      closeWithDelay(event.nativeEvent, false);
    }
  }), [closeWithDelay]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function FloatingDelayGroup(props) {
  const {
    children,
    delay,
    timeoutMs = 0
  } = props;
  const [state, setState] = React.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay,
    timeoutMs,
    initialDelay: delay,
    currentId: null,
    isInstantPhase: false
  });
  const initialCurrentIdRef = React.useRef(null);
  const setCurrentId = React.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  index(() => {
    if (state.currentId) {
      if (initialCurrentIdRef.current === null) {
        initialCurrentIdRef.current = state.currentId;
      } else if (!state.isInstantPhase) {
        setState({
          isInstantPhase: true
        });
      }
    } else {
      if (state.isInstantPhase) {
        setState({
          isInstantPhase: false
        });
      }
      initialCurrentIdRef.current = null;
    }
  }, [state.currentId, state.isInstantPhase]);
  return React.createElement(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId])
  }, children);
}
function useDelayGroup(context, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open,
    onOpenChange,
    floatingId
  } = context;
  const {
    id: optionId
  } = options;
  const id = optionId != null ? optionId : floatingId;
  const groupContext = useDelayGroupContext();
  const {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  index(() => {
    if (!currentId)
      return;
    setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    });
    if (currentId !== id) {
      onOpenChange(false);
    }
  }, [id, onOpenChange, setState, currentId, initialDelay]);
  index(() => {
    function unset() {
      onOpenChange(false);
      setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (!currentId)
      return;
    if (!open && currentId === id) {
      if (timeoutMs) {
        const timeout = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout);
        };
      }
      unset();
    }
  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
  index(() => {
    if (setCurrentId === NOOP || !open)
      return;
    setCurrentId(id);
  }, [open, setCurrentId, id]);
  return groupContext;
}
function getAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node) => node.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function getChildren(nodes, id) {
  let allChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
        var _node$context2;
        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
function getDeepestNode(nodes, id) {
  let deepestNodeId;
  let maxDepth = -1;
  function findDeepest(nodeId, depth) {
    if (depth > maxDepth) {
      deepestNodeId = nodeId;
      maxDepth = depth;
    }
    const children = getChildren(nodes, nodeId);
    children.forEach((child) => {
      findDeepest(child.id, depth + 1);
    });
  }
  findDeepest(id, 0);
  return nodes.find((node) => node.id === deepestNodeId);
}
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script")
        return;
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  }
  lockCount$1++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterValue = (counterMap.get(element) || 0) - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
function getTabbableIn(container, direction) {
  const allTabbable = tabbable(container, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
function useFloatingPortalNode(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    id,
    root
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const [portalNode, setPortalNode] = React.useState(null);
  const portalNodeRef = React.useRef(null);
  index(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index(() => {
    if (!uniqueId)
      return;
    if (portalNodeRef.current)
      return;
    const existingIdRoot = id ? document.getElementById(id) : null;
    if (!existingIdRoot)
      return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, uniqueId]);
  index(() => {
    if (!uniqueId)
      return;
    if (portalNodeRef.current)
      return;
    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container && !isElement(container))
      container = container.current;
    container = container || document.body;
    let idWrapper = null;
    if (id) {
      idWrapper = document.createElement("div");
      idWrapper.id = id;
      container.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container = idWrapper || container;
    container.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, root, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id,
    root = null,
    preserveTabOrder = true
  } = props;
  const portalNode = useFloatingPortalNode({
    id,
    root
  });
  const [focusManagerState, setFocusManagerState] = React.useState(null);
  const beforeOutsideRef = React.useRef(null);
  const afterOutsideRef = React.useRef(null);
  const beforeInsideRef = React.useRef(null);
  const afterInsideRef = React.useRef(null);
  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
  const open = focusManagerState == null ? void 0 : focusManagerState.open;
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  React.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, modal]);
  React.useEffect(() => {
    if (!portalNode)
      return;
    if (open)
      return;
    enableFocusInside(portalNode);
  }, [open, portalNode]);
  return React.createElement(PortalContext.Provider, {
    value: React.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && React.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null || prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && React.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), portalNode && ReactDOM.createPortal(children, portalNode), shouldRenderGuards && portalNode && React.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null || nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
      }
    }
  }));
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
}
function addPreviouslyFocusedElement(element) {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
  let tabbableEl = element;
  if (!tabbableEl || getNodeName(tabbableEl) === "body")
    return;
  if (!isTabbable(tabbableEl, getTabbableOptions())) {
    const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];
    if (tabbableChild) {
      tabbableEl = tabbableChild;
    }
  }
  previouslyFocusedElements.push(tabbableEl);
  if (previouslyFocusedElements.length > LIST_LIMIT) {
    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
  }
}
function getPreviouslyFocusedElement() {
  return previouslyFocusedElements.slice().reverse().find((el) => el.isConnected);
}
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = props;
  const {
    open,
    refs,
    nodeId,
    onOpenChange,
    events,
    dataRef,
    floatingId,
    elements: {
      domReference,
      floating
    }
  } = context;
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const guards = supportsInert() ? _guards : true;
  const orderRef = useLatestRef(order);
  const initialFocusRef = useLatestRef(initialFocus);
  const returnFocusRef = useLatestRef(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const startDismissButtonRef = React.useRef(null);
  const endDismissButtonRef = React.useRef(null);
  const preventReturnFocusRef = React.useRef(false);
  const isPointerDownRef = React.useRef(false);
  const tabbableIndexRef = React.useRef(-1);
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useEffectEvent(function(container) {
    if (container === void 0) {
      container = floatingFocusElement;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useEffectEvent((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floatingFocusElement && type === "floating") {
        return floatingFocusElement;
      }
      return content;
    }).filter(Boolean).flat();
  });
  React.useEffect(() => {
    preventReturnFocusRef.current = false;
  }, [disabled]);
  React.useEffect(() => {
    if (disabled)
      return;
    if (!modal)
      return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  React.useEffect(() => {
    if (disabled)
      return;
    if (!floating)
      return;
    function handleFocusIn(event) {
      const target = getTarget(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]);
  React.useEffect(() => {
    if (disabled)
      return;
    if (!closeOnFocusOut)
      return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      queueMicrotask(() => {
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4;
          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
        })));
        if (restoreFocus && movedToUnrelatedNode && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event, "focus-out");
        }
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, floatingFocusElement, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox]);
  React.useEffect(() => {
    var _portalContext$portal;
    if (disabled)
      return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (floating) {
      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null);
      const cleanup2 = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);
      return () => {
        cleanup2();
      };
    }
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);
  index(() => {
    if (disabled || !isHTMLElement(floatingFocusElement))
      return;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floatingFocusElement
        });
      }
    });
  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index(() => {
    if (disabled || !floatingFocusElement)
      return;
    let preventReturnFocusScroll = false;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    const contextData = dataRef.current;
    let openEvent = contextData.openEvent;
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        open: open2,
        reason,
        event,
        nested
      } = _ref;
      if (open2) {
        openEvent = event;
      }
      if (reason === "escape-key" && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      if (reason === "hover" && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press")
        return;
      if (nested) {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = true;
      } else {
        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));
      }
    }
    events.on("openchange", onOpenChange2);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1");
    fallbackEl.setAttribute("aria-hidden", "true");
    Object.assign(fallbackEl.style, HIDDEN_STYLES);
    if (isInsidePortal && domReference) {
      domReference.insertAdjacentElement("afterend", fallbackEl);
    }
    return () => {
      events.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
        var _node$context5;
        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
      });
      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ["click", "mousedown"].includes(openEvent.type);
      if (shouldFocusReference && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      const returnElement = getPreviouslyFocusedElement() || fallbackEl;
      queueMicrotask(() => {
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
        ) {
          returnElement.focus({
            preventScroll: preventReturnFocusScroll
          });
        }
        fallbackEl.remove();
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, refs, events, tree, nodeId, isInsidePortal, domReference]);
  index(() => {
    if (disabled)
      return;
    if (!portalContext)
      return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      refs
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);
  index(() => {
    if (disabled)
      return;
    if (!floatingFocusElement)
      return;
    if (typeof MutationObserver !== "function")
      return;
    if (ignoreInitialFocus)
      return;
    const handleMutation = () => {
      const tabIndex = floatingFocusElement.getAttribute("tabindex");
      const tabbableContent = getTabbableContent();
      const activeEl = activeElement(getDocument(floating));
      const tabbableIndex = tabbableContent.indexOf(activeEl);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
      if (orderRef.current.includes("floating") || activeEl !== refs.domReference.current && tabbableContent.length === 0) {
        if (tabIndex !== "0") {
          floatingFocusElement.setAttribute("tabindex", "0");
        }
      } else if (tabIndex !== "-1") {
        floatingFocusElement.setAttribute("tabindex", "-1");
      }
    };
    handleMutation();
    const observer = new MutationObserver(handleMutation);
    observer.observe(floatingFocusElement, {
      childList: true,
      subtree: true,
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [disabled, floating, floatingFocusElement, refs, orderRef, getTabbableContent, ignoreInitialFocus]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return React.createElement(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent)
    }, typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss");
  }
  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return React.createElement(React.Fragment, null, shouldRenderGuards && React.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: (event) => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null || nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
        }
      }
    }
  }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && React.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: (event) => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        if (closeOnFocusOut) {
          preventReturnFocusRef.current = true;
        }
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null || prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
        }
      }
    }
  }));
}
function enableScrollLock() {
  const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
function useClick(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = context;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = props;
  const pointerTypeRef = React.useRef();
  const didKeyDownRef = React.useRef(false);
  const reference = React.useMemo(() => ({
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onMouseDown(event) {
      const pointerType = pointerTypeRef.current;
      if (event.button !== 0)
        return;
      if (eventOption === "click")
        return;
      if (isMouseLikePointerType(pointerType, true) && ignoreMouse)
        return;
      if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "mousedown" : true)) {
        onOpenChange(false, event.nativeEvent, "click");
      } else {
        event.preventDefault();
        onOpenChange(true, event.nativeEvent, "click");
      }
    },
    onClick(event) {
      const pointerType = pointerTypeRef.current;
      if (eventOption === "mousedown" && pointerTypeRef.current) {
        pointerTypeRef.current = void 0;
        return;
      }
      if (isMouseLikePointerType(pointerType, true) && ignoreMouse)
        return;
      if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "click" : true)) {
        onOpenChange(false, event.nativeEvent, "click");
      } else {
        onOpenChange(true, event.nativeEvent, "click");
      }
    },
    onKeyDown(event) {
      pointerTypeRef.current = void 0;
      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
        return;
      }
      if (event.key === " " && !isSpaceIgnored(domReference)) {
        event.preventDefault();
        didKeyDownRef.current = true;
      }
      if (event.key === "Enter") {
        if (open && toggle) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      }
    },
    onKeyUp(event) {
      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
        return;
      }
      if (event.key === " " && didKeyDownRef.current) {
        didKeyDownRef.current = false;
        if (open && toggle) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      }
    }
  }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open, toggle]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function createVirtualElement(domElement, data) {
  let offsetX = null;
  let offsetY = null;
  let isAutoUpdateEvent = false;
  return {
    contextElement: domElement || void 0,
    getBoundingClientRect() {
      var _data$dataRef$current;
      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      const isXAxis = data.axis === "x" || data.axis === "both";
      const isYAxis = data.axis === "y" || data.axis === "both";
      const canTrackCursorOnAutoUpdate = ["mouseenter", "mousemove"].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || "") && data.pointerType !== "touch";
      let width = domRect.width;
      let height = domRect.height;
      let x = domRect.x;
      let y = domRect.y;
      if (offsetX == null && data.x && isXAxis) {
        offsetX = domRect.x - data.x;
      }
      if (offsetY == null && data.y && isYAxis) {
        offsetY = domRect.y - data.y;
      }
      x -= offsetX || 0;
      y -= offsetY || 0;
      width = 0;
      height = 0;
      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {
        width = data.axis === "y" ? domRect.width : 0;
        height = data.axis === "x" ? domRect.height : 0;
        x = isXAxis && data.x != null ? data.x : x;
        y = isYAxis && data.y != null ? data.y : y;
      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {
        height = data.axis === "x" ? domRect.height : height;
        width = data.axis === "y" ? domRect.width : width;
      }
      isAutoUpdateEvent = true;
      return {
        width,
        height,
        x,
        y,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x
      };
    }
  };
}
function isMouseBasedEvent(event) {
  return event != null && event.clientX != null;
}
function useClientPoint(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    dataRef,
    elements: {
      floating,
      domReference
    },
    refs
  } = context;
  const {
    enabled = true,
    axis = "both",
    x = null,
    y = null
  } = props;
  const initialRef = React.useRef(false);
  const cleanupListenerRef = React.useRef(null);
  const [pointerType, setPointerType] = React.useState();
  const [reactive, setReactive] = React.useState([]);
  const setReference = useEffectEvent((x2, y2) => {
    if (initialRef.current)
      return;
    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
      return;
    }
    refs.setPositionReference(createVirtualElement(domReference, {
      x: x2,
      y: y2,
      axis,
      dataRef,
      pointerType
    }));
  });
  const handleReferenceEnterOrMove = useEffectEvent((event) => {
    if (x != null || y != null)
      return;
    if (!open) {
      setReference(event.clientX, event.clientY);
    } else if (!cleanupListenerRef.current) {
      setReactive([]);
    }
  });
  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;
  const addListener = React.useCallback(() => {
    if (!openCheck || !enabled || x != null || y != null)
      return;
    const win = getWindow(floating);
    function handleMouseMove(event) {
      const target = getTarget(event);
      if (!contains(floating, target)) {
        setReference(event.clientX, event.clientY);
      } else {
        win.removeEventListener("mousemove", handleMouseMove);
        cleanupListenerRef.current = null;
      }
    }
    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {
      win.addEventListener("mousemove", handleMouseMove);
      const cleanup2 = () => {
        win.removeEventListener("mousemove", handleMouseMove);
        cleanupListenerRef.current = null;
      };
      cleanupListenerRef.current = cleanup2;
      return cleanup2;
    }
    refs.setPositionReference(domReference);
  }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);
  React.useEffect(() => {
    return addListener();
  }, [addListener, reactive]);
  React.useEffect(() => {
    if (enabled && !floating) {
      initialRef.current = false;
    }
  }, [enabled, floating]);
  React.useEffect(() => {
    if (!enabled && open) {
      initialRef.current = true;
    }
  }, [enabled, open]);
  index(() => {
    if (enabled && (x != null || y != null)) {
      initialRef.current = false;
      setReference(x, y);
    }
  }, [enabled, x, y, setReference]);
  const reference = React.useMemo(() => {
    function setPointerTypeRef(_ref) {
      let {
        pointerType: pointerType2
      } = _ref;
      setPointerType(pointerType2);
    }
    return {
      onPointerDown: setPointerTypeRef,
      onPointerEnter: setPointerTypeRef,
      onMouseMove: handleReferenceEnterOrMove,
      onMouseEnter: handleReferenceEnterOrMove
    };
  }, [handleReferenceEnterOrMove]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React.useRef(false);
  const endedOrStartedInsideRef = React.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL = getComputedStyle(target).direction === "rtl";
        if (isRTL) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    const doc = getDocument(elements.floating);
    escapeKey && doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(elements.domReference)) {
        ancestors = getOverflowAncestors(elements.domReference);
      }
      if (isElement(elements.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
      }
      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      if (referencePress) {
        onOpenChange(false, event.nativeEvent, "reference-press");
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React.useRef({});
  const [events] = React.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React.useState(null);
  const [positionReference, _setPositionReference] = React.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.reference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
function useFocus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context;
  const {
    enabled = true,
    visibleOnly = true
  } = props;
  const blockFocusRef = React.useRef(false);
  const timeoutRef = React.useRef();
  const keyboardModalityRef = React.useRef(true);
  React.useEffect(() => {
    if (!enabled)
      return;
    const win = getWindow(elements.domReference);
    function onBlur() {
      if (!open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference))) {
        blockFocusRef.current = true;
      }
    }
    function onKeyDown() {
      keyboardModalityRef.current = true;
    }
    win.addEventListener("blur", onBlur);
    win.addEventListener("keydown", onKeyDown, true);
    return () => {
      win.removeEventListener("blur", onBlur);
      win.removeEventListener("keydown", onKeyDown, true);
    };
  }, [elements.domReference, open, enabled]);
  React.useEffect(() => {
    if (!enabled)
      return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      if (reason === "reference-press" || reason === "escape-key") {
        blockFocusRef.current = true;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]);
  React.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  const reference = React.useMemo(() => ({
    onPointerDown(event) {
      if (isVirtualPointerEvent(event.nativeEvent))
        return;
      keyboardModalityRef.current = false;
    },
    onMouseLeave() {
      blockFocusRef.current = false;
    },
    onFocus(event) {
      if (blockFocusRef.current)
        return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        try {
          if (isSafari() && isMac())
            throw Error();
          if (!target.matches(":focus-visible"))
            return;
        } catch (e) {
          if (!keyboardModalityRef.current && !isTypeableElement(target)) {
            return;
          }
        }
      }
      onOpenChange(true, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = false;
      const relatedTarget = event.relatedTarget;
      const nativeEvent = event.nativeEvent;
      const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        if (!relatedTarget && activeEl === elements.domReference)
          return;
        if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard) {
          return;
        }
        onOpenChange(false, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context, props) {
  const {
    open,
    onOpenChange,
    elements
  } = context;
  const {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {
    },
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    cols = 1,
    scrollItemIntoView = true,
    virtualItemRef,
    itemSizes,
    dense = false
  } = props;
  if (true) {
    if (allowEscape) {
      if (!loop) {
        warn("`useListNavigation` looping must be enabled to allow escaping.");
      }
      if (!virtual) {
        warn("`useListNavigation` must be virtual to allow escaping.");
      }
    }
    if (orientation === "vertical" && cols > 1) {
      warn("In grid list navigation mode (`cols` > 1), the `orientation` should", 'be either "horizontal" or "both".');
    }
  }
  const floatingFocusElement = getFloatingFocusElement(elements.floating);
  const floatingFocusElementRef = useLatestRef(floatingFocusElement);
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const onNavigate = useEffectEvent(unstable_onNavigate);
  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);
  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = React.useRef(null);
  const isPointerModalityRef = React.useRef(true);
  const previousOnNavigateRef = React.useRef(onNavigate);
  const previousMountedRef = React.useRef(!!elements.floating);
  const previousOpenRef = React.useRef(open);
  const forceSyncFocus = React.useRef(false);
  const forceScrollIntoViewRef = React.useRef(false);
  const disabledIndicesRef = useLatestRef(disabledIndices);
  const latestOpenRef = useLatestRef(open);
  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
  const selectedIndexRef = useLatestRef(selectedIndex);
  const [activeId, setActiveId] = React.useState();
  const [virtualId, setVirtualId] = React.useState();
  const focusItem = useEffectEvent(function(listRef2, indexRef2, forceScrollIntoView) {
    if (forceScrollIntoView === void 0) {
      forceScrollIntoView = false;
    }
    function runFocus(item2) {
      if (virtual) {
        setActiveId(item2.id);
        tree == null || tree.events.emit("virtualfocus", item2);
        if (virtualItemRef) {
          virtualItemRef.current = item2;
        }
      } else {
        enqueueFocus(item2, {
          preventScroll: true,
          // Mac Safari does not move the virtual cursor unless the focus call
          // is sync. However, for the very first focus call, we need to wait
          // for the position to be ready in order to prevent unwanted
          // scrolling. This means the virtual cursor will not move to the first
          // item when first opening the floating element, but will on
          // subsequent calls. `preventScroll` is supported in modern Safari,
          // so we can use that instead.
          // iOS Safari must be async or the first item will not be focused.
          sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
        });
      }
    }
    const initialItem = listRef2.current[indexRef2.current];
    if (initialItem) {
      runFocus(initialItem);
    }
    requestAnimationFrame(() => {
      const waitedItem = listRef2.current[indexRef2.current] || initialItem;
      if (!waitedItem)
        return;
      if (!initialItem) {
        runFocus(waitedItem);
      }
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
          block: "nearest",
          inline: "nearest"
        } : scrollIntoViewOptions);
      }
    });
  });
  index(() => {
    document.createElement("div").focus({
      get preventScroll() {
        isPreventScrollSupported = true;
        return false;
      }
    });
  }, []);
  index(() => {
    if (!enabled)
      return;
    if (open && elements.floating) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        indexRef.current = selectedIndex;
        onNavigate(selectedIndex);
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current(null);
    }
  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);
  index(() => {
    if (!enabled)
      return;
    if (open && elements.floating) {
      if (activeIndex == null) {
        forceSyncFocus.current = false;
        if (selectedIndexRef.current != null) {
          return;
        }
        if (previousMountedRef.current) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        }
        if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          let runs = 0;
          const waitForListPopulated = () => {
            if (listRef.current[0] == null) {
              if (runs < 2) {
                const scheduler = runs ? requestAnimationFrame : queueMicrotask;
                scheduler(waitForListPopulated);
              }
              runs++;
            } else {
              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
              keyRef.current = null;
              onNavigate(indexRef.current);
            }
          };
          waitForListPopulated();
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);
        forceScrollIntoViewRef.current = false;
      }
    }
  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
  index(() => {
    var _nodes$find;
    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {
      return;
    }
    const nodes = tree.nodesRef.current;
    const parent = (_nodes$find = nodes.find((node) => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;
    const activeEl = activeElement(getDocument(elements.floating));
    const treeContainsActiveEl = nodes.some((node) => node.context && contains(node.context.elements.floating, activeEl));
    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
      parent.focus({
        preventScroll: true
      });
    }
  }, [enabled, elements.floating, tree, parentId, virtual]);
  index(() => {
    if (!enabled)
      return;
    if (!tree)
      return;
    if (!virtual)
      return;
    if (parentId)
      return;
    function handleVirtualFocus(item2) {
      setVirtualId(item2.id);
      if (virtualItemRef) {
        virtualItemRef.current = item2;
      }
    }
    tree.events.on("virtualfocus", handleVirtualFocus);
    return () => {
      tree.events.off("virtualfocus", handleVirtualFocus);
    };
  }, [enabled, tree, virtual, parentId, virtualItemRef]);
  index(() => {
    previousOnNavigateRef.current = onNavigate;
    previousMountedRef.current = !!elements.floating;
  });
  index(() => {
    if (!open) {
      keyRef.current = null;
    }
  }, [open]);
  index(() => {
    previousOpenRef.current = open;
  }, [open]);
  const hasActiveIndex = activeIndex != null;
  const item = React.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!open)
        return;
      const index2 = listRef.current.indexOf(currentTarget);
      if (index2 !== -1) {
        onNavigate(index2);
      }
    }
    const props2 = {
      onFocus(_ref) {
        let {
          currentTarget
        } = _ref;
        syncCurrentTarget(currentTarget);
      },
      onClick: (_ref2) => {
        let {
          currentTarget
        } = _ref2;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...focusItemOnHover && {
        onMouseMove(_ref3) {
          let {
            currentTarget
          } = _ref3;
          syncCurrentTarget(currentTarget);
        },
        onPointerLeave(_ref4) {
          let {
            pointerType
          } = _ref4;
          if (!isPointerModalityRef.current || pointerType === "touch") {
            return;
          }
          indexRef.current = -1;
          focusItem(listRef, indexRef);
          onNavigate(null);
          if (!virtual) {
            enqueueFocus(floatingFocusElementRef.current, {
              preventScroll: true
            });
          }
        }
      }
    };
    return props2;
  }, [open, floatingFocusElementRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
  const commonOnKeyDown = useEffectEvent((event) => {
    isPointerModalityRef.current = false;
    forceSyncFocus.current = true;
    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {
      return;
    }
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
      stopEvent(event);
      onOpenChange(false, event.nativeEvent, "list-navigation");
      if (isHTMLElement(elements.domReference) && !virtual) {
        elements.domReference.focus();
      }
      return;
    }
    const currentIndex = indexRef.current;
    const minIndex = getMinIndex(listRef, disabledIndices);
    const maxIndex = getMaxIndex(listRef, disabledIndices);
    if (event.key === "Home") {
      stopEvent(event);
      indexRef.current = minIndex;
      onNavigate(indexRef.current);
    }
    if (event.key === "End") {
      stopEvent(event);
      indexRef.current = maxIndex;
      onNavigate(indexRef.current);
    }
    if (cols > 1) {
      const sizes = itemSizes || Array.from({
        length: listRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isDisabled(listRef.current, index3, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isDisabled(listRef.current, index3, disabledIndices) ? cellIndex : foundIndex, -1);
      const index2 = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || listRef.current.map((_, index3) => isDisabled(listRef.current, index3) ? index3 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          indexRef.current > maxIndex ? minIndex : indexRef.current,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction
          // we're moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
        ),
        stopEvent: true
      })];
      if (index2 != null) {
        indexRef.current = index2;
        onNavigate(indexRef.current);
      }
      if (orientation === "both") {
        return;
      }
    }
    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent(event);
      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
        onNavigate(indexRef.current);
        return;
      }
      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loop) {
          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          });
        } else {
          indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          }));
        }
      } else {
        if (loop) {
          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          });
        } else {
          indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          }));
        }
      }
      if (isIndexOutOfBounds(listRef, indexRef.current)) {
        onNavigate(null);
      } else {
        onNavigate(indexRef.current);
      }
    }
  });
  const ariaActiveDescendantProp = React.useMemo(() => {
    return virtual && open && hasActiveIndex && {
      "aria-activedescendant": virtualId || activeId
    };
  }, [virtual, open, hasActiveIndex, virtualId, activeId]);
  const floating = React.useMemo(() => {
    return {
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ...!isTypeableCombobox(elements.domReference) && ariaActiveDescendantProp,
      onKeyDown: commonOnKeyDown,
      onPointerMove() {
        isPointerModalityRef.current = true;
      }
    };
  }, [ariaActiveDescendantProp, commonOnKeyDown, elements.domReference, orientation]);
  const reference = React.useMemo(() => {
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    return {
      ...ariaActiveDescendantProp,
      onKeyDown(event) {
        isPointerModalityRef.current = false;
        const isArrowKey = event.key.indexOf("Arrow") === 0;
        const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
        const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);
        const isMainKey = isMainOrientationKey(event.key, orientation);
        const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
        if (virtual && open) {
          const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node) => node.parentId == null);
          const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;
          if (isArrowKey && deepestNode && virtualItemRef) {
            const eventObject = new KeyboardEvent("keydown", {
              key: event.key,
              bubbles: true
            });
            if (isCrossOpenKey || isCrossCloseKey) {
              var _deepestNode$context, _deepestNode$context2;
              const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;
              const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item2) => (item2 == null ? void 0 : item2.id) === activeId) : null;
              if (dispatchItem) {
                stopEvent(event);
                dispatchItem.dispatchEvent(eventObject);
                setVirtualId(void 0);
              }
            }
            if (isMainKey && deepestNode.context) {
              if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {
                var _deepestNode$context$;
                stopEvent(event);
                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);
                return;
              }
            }
          }
          return commonOnKeyDown(event);
        }
        if (!open && !openOnArrowKeyDown && isArrowKey) {
          return;
        }
        if (isNavigationKey) {
          keyRef.current = nested && isMainKey ? null : event.key;
        }
        if (nested) {
          if (isCrossOpenKey) {
            stopEvent(event);
            if (open) {
              indexRef.current = getMinIndex(listRef, disabledIndicesRef.current);
              onNavigate(indexRef.current);
            } else {
              onOpenChange(true, event.nativeEvent, "list-navigation");
            }
          }
          return;
        }
        if (isMainKey) {
          if (selectedIndex != null) {
            indexRef.current = selectedIndex;
          }
          stopEvent(event);
          if (!open && openOnArrowKeyDown) {
            onOpenChange(true, event.nativeEvent, "list-navigation");
          } else {
            commonOnKeyDown(event);
          }
          if (open) {
            onNavigate(indexRef.current);
          }
        }
      },
      onFocus() {
        if (open && !virtual) {
          onNavigate(null);
        }
      },
      onPointerDown: checkVirtualPointer,
      onMouseDown: checkVirtualMouse,
      onClick: checkVirtualMouse
    };
  }, [activeId, ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function useRole(context, props) {
  var _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const referenceId = useId();
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = React.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : void 0,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role === "select" && {
        "aria-autocomplete": "none"
      },
      ...role === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role]);
  const floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = React.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected
        };
      case "combobox": {
        return {
          ...commonProps,
          ...active && {
            "aria-selected": true
          }
        };
      }
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function execWithArgsOrReturn(valueOrFn, args) {
  return typeof valueOrFn === "function" ? valueOrFn(args) : valueOrFn;
}
function useDelayUnmount(open, durationMs) {
  const [isMounted, setIsMounted] = React.useState(open);
  if (open && !isMounted) {
    setIsMounted(true);
  }
  React.useEffect(() => {
    if (!open && isMounted) {
      const timeout = setTimeout(() => setIsMounted(false), durationMs);
      return () => clearTimeout(timeout);
    }
  }, [open, isMounted, durationMs]);
  return isMounted;
}
function useTransitionStatus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements: {
      floating
    }
  } = context;
  const {
    duration = 250
  } = props;
  const isNumberDuration = typeof duration === "number";
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [status, setStatus] = React.useState("unmounted");
  const isMounted = useDelayUnmount(open, closeDuration);
  if (!isMounted && status === "close") {
    setStatus("unmounted");
  }
  index(() => {
    if (!floating)
      return;
    if (open) {
      setStatus("initial");
      const frame = requestAnimationFrame(() => {
        setStatus("open");
      });
      return () => {
        cancelAnimationFrame(frame);
      };
    }
    setStatus("close");
  }, [open, floating]);
  return {
    isMounted,
    status
  };
}
function useTransitionStyles(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    initial: unstable_initial = {
      opacity: 0
    },
    open: unstable_open,
    close: unstable_close,
    common: unstable_common,
    duration = 250
  } = props;
  const placement = context.placement;
  const side = placement.split("-")[0];
  const fnArgs = React.useMemo(() => ({
    side,
    placement
  }), [side, placement]);
  const isNumberDuration = typeof duration === "number";
  const openDuration = (isNumberDuration ? duration : duration.open) || 0;
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [styles, setStyles] = React.useState(() => ({
    ...execWithArgsOrReturn(unstable_common, fnArgs),
    ...execWithArgsOrReturn(unstable_initial, fnArgs)
  }));
  const {
    isMounted,
    status
  } = useTransitionStatus(context, {
    duration
  });
  const initialRef = useLatestRef(unstable_initial);
  const openRef = useLatestRef(unstable_open);
  const closeRef = useLatestRef(unstable_close);
  const commonRef = useLatestRef(unstable_common);
  index(() => {
    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);
    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);
    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);
    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {
      acc[key] = "";
      return acc;
    }, {});
    if (status === "initial") {
      setStyles((styles2) => ({
        transitionProperty: styles2.transitionProperty,
        ...commonStyles,
        ...initialStyles
      }));
    }
    if (status === "open") {
      setStyles({
        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(","),
        transitionDuration: openDuration + "ms",
        ...commonStyles,
        ...openStyles
      });
    }
    if (status === "close") {
      const styles2 = closeStyles || initialStyles;
      setStyles({
        transitionProperty: Object.keys(styles2).map(camelCaseToKebabCase).join(","),
        transitionDuration: closeDuration + "ms",
        ...commonStyles,
        ...styles2
      });
    }
  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);
  return {
    isMounted,
    styles
  };
}
function useTypeahead(context, props) {
  var _ref;
  const {
    open,
    dataRef
  } = context;
  const {
    listRef,
    activeIndex,
    onMatch: unstable_onMatch,
    onTypingChange: unstable_onTypingChange,
    enabled = true,
    findMatch = null,
    resetMs = 750,
    ignoreKeys = [],
    selectedIndex = null
  } = props;
  const timeoutIdRef = React.useRef();
  const stringRef = React.useRef("");
  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);
  const matchIndexRef = React.useRef(null);
  const onMatch = useEffectEvent(unstable_onMatch);
  const onTypingChange = useEffectEvent(unstable_onTypingChange);
  const findMatchRef = useLatestRef(findMatch);
  const ignoreKeysRef = useLatestRef(ignoreKeys);
  index(() => {
    if (open) {
      clearTimeout(timeoutIdRef.current);
      matchIndexRef.current = null;
      stringRef.current = "";
    }
  }, [open]);
  index(() => {
    if (open && stringRef.current === "") {
      var _ref2;
      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;
    }
  }, [open, selectedIndex, activeIndex]);
  const setTypingChange = useEffectEvent((value) => {
    if (value) {
      if (!dataRef.current.typing) {
        dataRef.current.typing = value;
        onTypingChange(value);
      }
    } else {
      if (dataRef.current.typing) {
        dataRef.current.typing = value;
        onTypingChange(value);
      }
    }
  });
  const onKeyDown = useEffectEvent((event) => {
    function getMatchingIndex(list, orderedList, string) {
      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text) => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);
      return str ? list.indexOf(str) : -1;
    }
    const listContent = listRef.current;
    if (stringRef.current.length > 0 && stringRef.current[0] !== " ") {
      if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {
        setTypingChange(false);
      } else if (event.key === " ") {
        stopEvent(event);
      }
    }
    if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.
    event.key.length !== 1 || // Modifier key.
    event.ctrlKey || event.metaKey || event.altKey) {
      return;
    }
    if (open && event.key !== " ") {
      stopEvent(event);
      setTypingChange(true);
    }
    const allowRapidSuccessionOfFirstLetter = listContent.every((text) => {
      var _text$, _text$2;
      return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
    });
    if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
      stringRef.current = "";
      prevIndexRef.current = matchIndexRef.current;
    }
    stringRef.current += event.key;
    clearTimeout(timeoutIdRef.current);
    timeoutIdRef.current = setTimeout(() => {
      stringRef.current = "";
      prevIndexRef.current = matchIndexRef.current;
      setTypingChange(false);
    }, resetMs);
    const prevIndex = prevIndexRef.current;
    const index2 = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);
    if (index2 !== -1) {
      onMatch(index2);
      matchIndexRef.current = index2;
    } else if (event.key !== " ") {
      stringRef.current = "";
      setTypingChange(false);
    }
  });
  const reference = React.useMemo(() => ({
    onKeyDown
  }), [onKeyDown]);
  const floating = React.useMemo(() => {
    return {
      onKeyDown,
      onKeyUp(event) {
        if (event.key === " ") {
          setTypingChange(false);
        }
      }
    };
  }, [onKeyDown, setTypingChange]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = React.useRef(false);
  const prevScrollTopRef = React.useRef(null);
  const initialOverflowRef = React.useRef(null);
  React.useEffect(() => {
    if (!enabled)
      return;
    function onWheel(e) {
      if (e.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e.preventDefault();
        ReactDOM.flushSync(() => {
          onChange((d) => d + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = React.useMemo(() => ({
    onKeyDown() {
      controlledScrollingRef.current = true;
    },
    onWheel() {
      controlledScrollingRef.current = false;
    },
    onPointerMove() {
      controlledScrollingRef.current = false;
    },
    onScroll() {
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!overflowRef.current || !el || !controlledScrollingRef.current) {
        return;
      }
      if (prevScrollTopRef.current !== null) {
        const scrollDiff = el.scrollTop - prevScrollTopRef.current;
        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
          ReactDOM.flushSync(() => onChange((d) => d + scrollDiff));
        }
      }
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
      });
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return React.useMemo(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside2 = false;
  const length = polygon.length;
  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    buffer = 0.5,
    blockPointerEvents = false,
    requireIntent = true
  } = options;
  let timeoutId2;
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = performance.now();
  function getCursorSpeed(x, y) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x;
      lastY = y;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x - lastX;
    const deltaY = y - lastY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance / elapsedTime;
    lastX = x;
    lastY = y;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn = (_ref) => {
    let {
      x,
      y,
      placement,
      elements,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeout(timeoutId2);
        onClose();
      }
      clearTimeout(timeoutId2);
      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains(elements.floating, target);
      const isOverReferenceEl = contains(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left = (isFloatingWider ? refRect : rect).left;
      const right = (isFloatingWider ? refRect : rect).right;
      const top = (isFloatingTaller ? refRect : rect).top;
      const bottom = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }
      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {
        return;
      }
      if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2) => {
        let {
          context
        } = _ref2;
        return context == null ? void 0 : context.open;
      })) {
        return;
      }
      if (side === "top" && y >= refRect.bottom - 1 || side === "bottom" && y <= refRect.top + 1 || side === "left" && x >= refRect.right - 1 || side === "right" && x <= refRect.left + 1) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
          break;
        case "bottom":
          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
          break;
        case "left":
          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
          break;
        case "right":
          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
          break;
      }
      function getPolygon(_ref3) {
        let [x2, y2] = _ref3;
        switch (side) {
          case "top": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [x2 + buffer + 1, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 + buffer + 1, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [x2 - buffer, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 - buffer, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return;
      }
      if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeoutId2 = window.setTimeout(close, 40);
      }
    };
  };
  fn.__options = {
    blockPointerEvents
  };
  return fn;
}
var React, import_react, ReactDOM, SafeReact, useInsertionEffect, useSafeInsertionEffect, ARROW_UP, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, rafId, index, FloatingListContext, CompositeContext, horizontalKeys, verticalKeys, allKeys, Composite, CompositeItem, serverHandoffComplete, count, genId, useReactId, useId, devMessageSet, FloatingArrow, FloatingNodeContext, FloatingTreeContext, useFloatingParentNodeId, useFloatingTree, safePolygonIdentifier, NOOP, FloatingDelayGroupContext, useDelayGroupContext, counterMap, uncontrolledElementsSet, markerMap, lockCount$1, supportsInert, unwrapHost, correctElements, getTabbableOptions, HIDDEN_STYLES, timeoutId, FocusGuard, PortalContext, attr, usePortalContext, FOCUSABLE_ATTRIBUTE, LIST_LIMIT, previouslyFocusedElements, VisuallyHiddenDismiss, lockCount, cleanup, FloatingOverlay, bubbleHandlerKeys, captureHandlerKeys, normalizeProp, ACTIVE_KEY, SELECTED_KEY, isPreventScrollSupported, componentRoleToAriaRoleMap, camelCaseToKebabCase, inner;
var init_floating_ui_react_esm = __esm({
  "node_modules/@floating-ui/react/dist/floating-ui.react.esm.js"() {
    React = __toESM(require_react());
    import_react = __toESM(require_react());
    init_floating_ui_react_utils();
    init_floating_ui_utils();
    init_floating_ui_utils_dom();
    init_index_esm();
    ReactDOM = __toESM(require_react_dom());
    init_floating_ui_react_dom();
    init_floating_ui_react_dom();
    SafeReact = {
      ...React
    };
    useInsertionEffect = SafeReact.useInsertionEffect;
    useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
    ARROW_UP = "ArrowUp";
    ARROW_DOWN = "ArrowDown";
    ARROW_LEFT = "ArrowLeft";
    ARROW_RIGHT = "ArrowRight";
    rafId = 0;
    index = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
    FloatingListContext = React.createContext({
      register: () => {
      },
      unregister: () => {
      },
      map: /* @__PURE__ */ new Map(),
      elementsRef: {
        current: []
      }
    });
    CompositeContext = React.createContext({
      activeIndex: 0,
      onNavigate: () => {
      }
    });
    horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
    verticalKeys = [ARROW_UP, ARROW_DOWN];
    allKeys = [...horizontalKeys, ...verticalKeys];
    Composite = React.forwardRef(function Composite2(props, forwardedRef) {
      const {
        render,
        orientation = "both",
        loop = true,
        cols = 1,
        disabledIndices,
        activeIndex: externalActiveIndex,
        onNavigate: externalSetActiveIndex,
        itemSizes,
        dense = false,
        ...domProps
      } = props;
      const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);
      const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
      const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
      const elementsRef = React.useRef([]);
      const renderElementProps = render && typeof render !== "function" ? render.props : {};
      const contextValue = React.useMemo(() => ({
        activeIndex,
        onNavigate
      }), [activeIndex, onNavigate]);
      const isGrid = cols > 1;
      function handleKeyDown(event) {
        if (!allKeys.includes(event.key))
          return;
        let nextIndex = activeIndex;
        const minIndex = getMinIndex(elementsRef, disabledIndices);
        const maxIndex = getMaxIndex(elementsRef, disabledIndices);
        if (isGrid) {
          const sizes = itemSizes || Array.from({
            length: elementsRef.current.length
          }, () => ({
            width: 1,
            height: 1
          }));
          const cellMap = buildCellMap(sizes, cols, dense);
          const minGridIndex = cellMap.findIndex((index2) => index2 != null && !isDisabled(elementsRef.current, index2, disabledIndices));
          const maxGridIndex = cellMap.reduce((foundIndex, index2, cellIndex) => index2 != null && !isDisabled(elementsRef.current, index2, disabledIndices) ? cellIndex : foundIndex, -1);
          const maybeNextIndex = cellMap[getGridNavigatedIndex({
            current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
          }, {
            event,
            orientation,
            loop,
            cols,
            // treat undefined (empty grid spaces) as disabled indices so we
            // don't end up in them
            disabledIndices: getCellIndices([...disabledIndices || elementsRef.current.map((_, index2) => isDisabled(elementsRef.current, index2) ? index2 : void 0), void 0], cellMap),
            minIndex: minGridIndex,
            maxIndex: maxGridIndex,
            prevIndex: getCellIndexOfCorner(
              activeIndex > maxIndex ? minIndex : activeIndex,
              sizes,
              cellMap,
              cols,
              // use a corner matching the edge closest to the direction we're
              // moving in so we don't end up in the same item. Prefer
              // top/left over bottom/right.
              event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
            )
          })];
          if (maybeNextIndex != null) {
            nextIndex = maybeNextIndex;
          }
        }
        const toEndKeys = {
          horizontal: [ARROW_RIGHT],
          vertical: [ARROW_DOWN],
          both: [ARROW_RIGHT, ARROW_DOWN]
        }[orientation];
        const toStartKeys = {
          horizontal: [ARROW_LEFT],
          vertical: [ARROW_UP],
          both: [ARROW_LEFT, ARROW_UP]
        }[orientation];
        const preventedKeys = isGrid ? allKeys : {
          horizontal: horizontalKeys,
          vertical: verticalKeys,
          both: allKeys
        }[orientation];
        if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
          if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
            nextIndex = minIndex;
          } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
            nextIndex = maxIndex;
          } else {
            nextIndex = findNonDisabledIndex(elementsRef, {
              startingIndex: nextIndex,
              decrement: toStartKeys.includes(event.key),
              disabledIndices
            });
          }
        }
        if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
          event.stopPropagation();
          if (preventedKeys.includes(event.key)) {
            event.preventDefault();
          }
          onNavigate(nextIndex);
          queueMicrotask(() => {
            enqueueFocus(elementsRef.current[nextIndex]);
          });
        }
      }
      const computedProps = {
        ...domProps,
        ...renderElementProps,
        ref: forwardedRef,
        "aria-orientation": orientation === "both" ? void 0 : orientation,
        onKeyDown(e) {
          domProps.onKeyDown == null || domProps.onKeyDown(e);
          renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
          handleKeyDown(e);
        }
      };
      return React.createElement(CompositeContext.Provider, {
        value: contextValue
      }, React.createElement(FloatingList, {
        elementsRef
      }, renderJsx(render, computedProps)));
    });
    CompositeItem = React.forwardRef(function CompositeItem2(props, forwardedRef) {
      const {
        render,
        ...domProps
      } = props;
      const renderElementProps = render && typeof render !== "function" ? render.props : {};
      const {
        activeIndex,
        onNavigate
      } = React.useContext(CompositeContext);
      const {
        ref,
        index: index2
      } = useListItem();
      const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
      const isActive = activeIndex === index2;
      const computedProps = {
        ...domProps,
        ...renderElementProps,
        ref: mergedRef,
        tabIndex: isActive ? 0 : -1,
        "data-active": isActive ? "" : void 0,
        onFocus(e) {
          domProps.onFocus == null || domProps.onFocus(e);
          renderElementProps.onFocus == null || renderElementProps.onFocus(e);
          onNavigate(index2);
        }
      };
      return renderJsx(render, computedProps);
    });
    serverHandoffComplete = false;
    count = 0;
    genId = () => (
      // Ensure the id is unique with multiple independent versions of Floating UI
      // on <React 18
      "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
    );
    useReactId = SafeReact.useId;
    useId = useReactId || useFloatingId;
    if (true) {
      devMessageSet = /* @__PURE__ */ new Set();
    }
    FloatingArrow = React.forwardRef(function FloatingArrow2(props, ref) {
      const {
        context: {
          placement,
          elements: {
            floating
          },
          middlewareData: {
            arrow: arrow2,
            shift: shift2
          }
        },
        width = 14,
        height = 7,
        tipRadius = 0,
        strokeWidth = 0,
        staticOffset,
        stroke,
        d,
        style: {
          transform,
          ...restStyle
        } = {},
        ...rest
      } = props;
      if (true) {
        if (!ref) {
          warn("The `ref` prop is required for `FloatingArrow`.");
        }
      }
      const clipPathId = useId();
      const [isRTL, setIsRTL] = React.useState(false);
      index(() => {
        if (!floating)
          return;
        const isRTL2 = getComputedStyle(floating).direction === "rtl";
        if (isRTL2) {
          setIsRTL(true);
        }
      }, [floating]);
      if (!floating) {
        return null;
      }
      const [side, alignment] = placement.split("-");
      const isVerticalSide = side === "top" || side === "bottom";
      let computedStaticOffset = staticOffset;
      if (isVerticalSide && shift2 != null && shift2.x || !isVerticalSide && shift2 != null && shift2.y) {
        computedStaticOffset = null;
      }
      const computedStrokeWidth = strokeWidth * 2;
      const halfStrokeWidth = computedStrokeWidth / 2;
      const svgX = width / 2 * (tipRadius / -8 + 1);
      const svgY = height / 2 * tipRadius / 4;
      const isCustomShape = !!d;
      const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
      let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
      if (computedStaticOffset && isRTL) {
        xOffsetProp = alignment === "end" ? "left" : "right";
      }
      const arrowX = (arrow2 == null ? void 0 : arrow2.x) != null ? computedStaticOffset || arrow2.x : "";
      const arrowY = (arrow2 == null ? void 0 : arrow2.y) != null ? computedStaticOffset || arrow2.y : "";
      const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
      const rotation = {
        top: isCustomShape ? "rotate(180deg)" : "",
        left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
        bottom: isCustomShape ? "" : "rotate(180deg)",
        right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
      }[side];
      return React.createElement("svg", _extends({}, rest, {
        "aria-hidden": true,
        ref,
        width: isCustomShape ? width : width + computedStrokeWidth,
        height: width,
        viewBox: "0 0 " + width + " " + (height > width ? height : width),
        style: {
          position: "absolute",
          pointerEvents: "none",
          [xOffsetProp]: arrowX,
          [yOffsetProp]: arrowY,
          [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
          transform: [rotation, transform].filter((t) => !!t).join(" "),
          ...restStyle
        }
      }), computedStrokeWidth > 0 && React.createElement("path", {
        clipPath: "url(#" + clipPathId + ")",
        fill: "none",
        stroke,
        strokeWidth: computedStrokeWidth + (d ? 0 : 1),
        d: dValue
      }), React.createElement("path", {
        stroke: computedStrokeWidth && !d ? rest.fill : "none",
        d: dValue
      }), React.createElement("clipPath", {
        id: clipPathId
      }, React.createElement("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + computedStrokeWidth,
        height: width
      })));
    });
    FloatingNodeContext = React.createContext(null);
    FloatingTreeContext = React.createContext(null);
    useFloatingParentNodeId = () => {
      var _React$useContext;
      return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
    };
    useFloatingTree = () => React.useContext(FloatingTreeContext);
    safePolygonIdentifier = createAttribute("safe-polygon");
    NOOP = () => {
    };
    FloatingDelayGroupContext = React.createContext({
      delay: 0,
      initialDelay: 0,
      timeoutMs: 0,
      currentId: null,
      setCurrentId: NOOP,
      setState: NOOP,
      isInstantPhase: false
    });
    useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
    counterMap = /* @__PURE__ */ new WeakMap();
    uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
    markerMap = {};
    lockCount$1 = 0;
    supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
    unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
    correctElements = (parent, targets) => targets.map((target) => {
      if (parent.contains(target)) {
        return target;
      }
      const correctedTarget = unwrapHost(target);
      if (parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      return null;
    }).filter((x) => x != null);
    getTabbableOptions = () => ({
      getShadowRoot: true,
      displayCheck: (
        // JSDOM does not support the `tabbable` library. To solve this we can
        // check if `ResizeObserver` is a real function (not polyfilled), which
        // determines if the current environment is JSDOM-like.
        typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
      )
    });
    HIDDEN_STYLES = {
      border: 0,
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "fixed",
      whiteSpace: "nowrap",
      width: "1px",
      top: 0,
      left: 0
    };
    FocusGuard = React.forwardRef(function FocusGuard2(props, ref) {
      const [role, setRole] = React.useState();
      index(() => {
        if (isSafari()) {
          setRole("button");
        }
        document.addEventListener("keydown", setActiveElementOnTab);
        return () => {
          document.removeEventListener("keydown", setActiveElementOnTab);
        };
      }, []);
      const restProps = {
        ref,
        tabIndex: 0,
        // Role is only for VoiceOver
        role,
        "aria-hidden": role ? void 0 : true,
        [createAttribute("focus-guard")]: "",
        style: HIDDEN_STYLES
      };
      return React.createElement("span", _extends({}, props, restProps));
    });
    PortalContext = React.createContext(null);
    attr = createAttribute("portal");
    usePortalContext = () => React.useContext(PortalContext);
    FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
    LIST_LIMIT = 20;
    previouslyFocusedElements = [];
    VisuallyHiddenDismiss = React.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
      return React.createElement("button", _extends({}, props, {
        type: "button",
        ref,
        tabIndex: -1,
        style: HIDDEN_STYLES
      }));
    });
    lockCount = 0;
    cleanup = () => {
    };
    FloatingOverlay = React.forwardRef(function FloatingOverlay2(props, ref) {
      const {
        lockScroll = false,
        ...rest
      } = props;
      index(() => {
        if (!lockScroll)
          return;
        lockCount++;
        if (lockCount === 1) {
          cleanup = enableScrollLock();
        }
        return () => {
          lockCount--;
          if (lockCount === 0) {
            cleanup();
          }
        };
      }, [lockScroll]);
      return React.createElement("div", _extends({
        ref
      }, rest, {
        style: {
          position: "fixed",
          overflow: "auto",
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...rest.style
        }
      }));
    });
    bubbleHandlerKeys = {
      pointerdown: "onPointerDown",
      mousedown: "onMouseDown",
      click: "onClick"
    };
    captureHandlerKeys = {
      pointerdown: "onPointerDownCapture",
      mousedown: "onMouseDownCapture",
      click: "onClickCapture"
    };
    normalizeProp = (normalizable) => {
      var _normalizable$escapeK, _normalizable$outside;
      return {
        escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
        outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
      };
    };
    ACTIVE_KEY = "active";
    SELECTED_KEY = "selected";
    isPreventScrollSupported = false;
    componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
    camelCaseToKebabCase = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? "-" : "") + $.toLowerCase());
    inner = (props) => ({
      name: "inner",
      options: props,
      async fn(state) {
        const {
          listRef,
          overflowRef,
          onFallbackChange,
          offset: innerOffset = 0,
          index: index2 = 0,
          minItemsVisible = 4,
          referenceOverflowThreshold = 0,
          scrollRef,
          ...detectOverflowOptions
        } = evaluate(props, state);
        const {
          rects,
          elements: {
            floating
          }
        } = state;
        const item = listRef.current[index2];
        const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
        const clientTop = floating.clientTop || scrollEl.clientTop;
        const floatingIsBordered = floating.clientTop !== 0;
        const scrollElIsBordered = scrollEl.clientTop !== 0;
        const floatingIsScrollEl = floating === scrollEl;
        if (true) {
          if (!state.placement.startsWith("bottom")) {
            warn('`placement` side must be "bottom" when using the `inner`', "middleware.");
          }
        }
        if (!item) {
          return {};
        }
        const nextArgs = {
          ...state,
          ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
        };
        const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
        const refOverflow = await detectOverflow(nextArgs, {
          ...detectOverflowOptions,
          elementContext: "reference"
        });
        const diffY = max(0, overflow.top);
        const nextY = nextArgs.y + diffY;
        const maxHeight = round(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
        scrollEl.style.maxHeight = maxHeight + "px";
        scrollEl.scrollTop = diffY;
        if (onFallbackChange) {
          const shouldFallback = scrollEl.scrollHeight > scrollEl.offsetHeight && scrollEl.offsetHeight < item.offsetHeight * minItemsVisible - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
          ReactDOM.flushSync(() => onFallbackChange(shouldFallback));
        }
        if (overflowRef) {
          overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
            ...nextArgs,
            y: nextY
          }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
        }
        return {
          y: nextY
        };
      }
    });
  }
});

export {
  require_clsx,
  require_toDate,
  require_addDays,
  require_addHours,
  require_addMinutes,
  require_addMonths,
  require_addQuarters,
  require_addSeconds,
  require_addWeeks,
  require_addYears,
  require_startOfDay,
  require_differenceInCalendarDays,
  require_differenceInCalendarMonths,
  require_getQuarter,
  require_differenceInCalendarQuarters,
  require_differenceInCalendarYears,
  require_endOfDay,
  require_endOfMonth,
  require_endOfWeek,
  require_endOfYear,
  require_startOfYear,
  require_startOfWeek,
  require_getISOWeek,
  require_isDate,
  require_isValid,
  require_format,
  require_getDate,
  require_getDay,
  require_getHours,
  require_getMinutes,
  require_getMonth,
  require_getSeconds,
  require_getTime,
  require_getYear,
  require_isAfter,
  require_isBefore,
  require_isEqual,
  require_isSameDay,
  require_isSameMonth,
  require_startOfQuarter,
  require_isSameQuarter,
  require_isSameYear,
  require_isWithinInterval,
  require_max,
  require_min,
  require_parse,
  require_parseISO,
  require_setMonth,
  require_set,
  require_setHours,
  require_setMinutes,
  require_setQuarter,
  require_setSeconds,
  require_setYear,
  require_startOfMonth,
  require_subDays,
  require_subMonths,
  require_subQuarters,
  require_subWeeks,
  require_subYears,
  floating_ui_react_esm_exports,
  init_floating_ui_react_esm
};
//# sourceMappingURL=chunk-Z4U43SR6.js.map
